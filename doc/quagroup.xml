<?xml version="1.0" encoding="utf-8"?>

<?LaTeX ExtraPreamble="\usepackage{amsmath}"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="quagroup">

<#Include SYSTEM "title.xml">

<TableOfContents/>

<Body>

<Chapter> <Heading>Introduction</Heading>

This is the manual for the &GAP; package <Package>QuaGroup</Package>, for 
doing computations with quantized enveloping algebras of semisimple Lie 
algebras.<P/>

Apart from the chapter you are currently reading, this document consists of 
two chapters. In Chapter <Ref Chap="chap2"/> we give 
a short summary of parts of the theory of quantized enveloping algebras. 
This fixes the notations and definitions that we use. Then in Chapter 
<Ref Chap="chap3"/> we describe the functions that 
constitute the package. <P/>

The package can be obtained from 
<URL>http://www.math.uu.nl/people/graaf/quagroup.html</URL> 
The directory <F>quagroup/doc</F> contains the manual of the package in 
<F>dvi</F>, <F>ps</F>, <F>pdf</F> and <F>html</F> format. 
The manual was built with the &GAP; share package 
<Package>GAPDoc</Package>, <Cite Key="LN01"/>. 
This means that, in order to be able to use the on-line help of 
<Package>QuaGroup</Package>, you have to install 
<Package>GAPDoc</Package> before calling 
<A>LoadPackage("quagroup");</A>. <P/>

The main algorithm of the package (on which virtually the whole functionality 
relies) is a method for computing with so-called PBW-type bases, analogous 
to Poincar\'{e}-Birkhoff-Witt bases in universal enveloping algebras. In 
both cases commutation relations between the generators are used. However, 
in the latter case all commutation relations are of the form <M>yx=xy+z</M>, 
where  <M>x,y</M> are generators, and <M>z</M> is a linear combination of 
generators. In the case of quantized enveloping algebras the 
situation is generally much more complicated. For example, in the quantized 
enveloping algebra of type <M>E_7</M> we have the following relation:

<Log><![CDATA[
F62*F26 = (q)*F26*F62+(1-q^2)*F28*F61+(-q+q^3)*F30*F60+(-q^4+q^2)*F31*F59+
          (-q^4+q^2)*F33*F58+(-q^3+q^5)*F34*F57+(q^4-q^6)*F35*F56+
          (-q+q^-1-q^5+q^7)*F36*F55+(q^6)*F54
]]></Log>


Due to the complexity of these commutation relations, some computations 
(even with rather small input) may take quite some time.<P/>

Remark: The package can deal with quantized enveloping algebras corresponding 
to root systems of rank at least up to eight, except <M>E_8</M>. In that case 
the 
computation of the necessary commutation relations took more than 2 GB. 
I wish to thank Steve Linton for trying this computation on the machines in 
St Andrews.<P/>

The following example illustrates some of the features of the package.<P/>


<Example><![CDATA[
gap> # We define a root system by giving its type:
gap> R:= RootSystem( "B", 2 );
<root system of type B2>
gap> # Corresponding to the root system we define a quantized enveloping algebra:
gap> U:= QuantizedUEA( R );
QuantumUEA( <root system of type B2>, Qpar = q )
gap> # It is generated by the generators of a so-called PBW-type basis:
gap> GeneratorsOfAlgebra( U );
[ F1, F2, F3, F4, K1, (-q^2+q^-2)*[ K1 ; 1 ]+K1, K2, (-q+q^-1)*[ K2 ; 1 ]+K2, 
  E1, E2, E3, E4 ]
gap> # We can construct highest-weight modules:
gap> V:= HighestWeightModule( U, [1,1] );
<16-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>
gap> # For modules of small dimension we can compute the corresponding
gap> # R-matrix:
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> V:= HighestWeightModule( U, [1,0] );;
gap> RMatrix( V );
[ [ q^2, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, q^3, 0, -q^4+q^2, 0, 0, 0, 0, 0 ], 
  [ 0, 0, q^3, 0, 0, 0, -q^4+q^2, 0, 0 ], [ 0, 0, 0, q^3, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, q^2, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, q^3, 0, -q^4+q^2, 0 ], 
  [ 0, 0, 0, 0, 0, 0, q^3, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, q^3, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, q^2 ] ]
gap> # We can compute elements of the canonical basis of the "negative" part
gap> # of a quantized enveloping algebra:
gap> U:= QuantizedUEA( RootSystem("F",4) );;
gap> B:= CanonicalBasis( U );
<canonical basis of QuantumUEA( <root system of type F4>, Qpar = q ) >
gap> p:= PBWElements( B, [0,1,2,1] ); 
[ F3*F9^(2)*F24, F3*F9*F23+(q^2)*F3*F9^(2)*F24, 
  (q^3+q)*F3*F9^(2)*F24+F7*F9*F24, (q^2)*F3*F9*F23+(q^4+q^2)*F3*F9^(2)*F
    24+(q)*F7*F9*F24+F7*F23, (q^4)*F3*F9^(2)*F24+(q)*F7*F9*F24+F8*F24, 
  (q^4)*F3*F9*F23+(q^6)*F3*F9^(2)*F24+(q^3)*F7*F9*F24+(q^2)*F7*F23+(q^2)*F8*F
    24+F9*F21, (q^3+q)*F3*F9*F23+(q^5+q^3)*F3*F9^(2)*F24+(q^2)*F7*F9*F24+(q)*F
    7*F23+(q)*F9*F21+F16 ]
gap> # We can construct (anti-) automorphisms of quantized enveloping
gap> # algebras:
gap> t:= AntiAutomorphismTau( U );
<anti-automorphism of QuantumUEA( <root system of type F4>, Qpar = q )>
gap> Image( t, p[1] );
(q^4)*F3*F9*F23+(q^6)*F3*F9^(2)*F24+(q^3)*F7*F9*F24+(q^2)*F7*F23+(q^2)*F8*F
24+F9*F21
gap> # (This is the sixth element of p.)
]]></Example>

</Chapter>

<Chapter Label="chap2"> <Heading>Background</Heading>

In this chapter we summarize some of the theoretical concepts with which 
<Package>QuaGroup</Package> operates. 

<Section Label="sec2.1"> <Heading>Gaussian Binomials</Heading>

Let <Math>v</Math> be an indeterminate over <Math>\mathbb{Q}</Math>. For a positive integer <Math>n</Math> 
we set
<Display> [n] = v^{n-1}+v^{n-3}+\cdots + v^{-n+3}+v^{-n+1}. </Display>
We say that <Math>[n]</Math> is the <E> Gaussian integer </E> corresponding to <Math>n</Math>. 
The <E> Gaussian factorial </E> <Math>[n]!</Math> is defined by
<Display> [0]! = 1, ~ [n]! = [n][n-1]\cdots [1], \text{ for } n>0.</Display>
Finally, the <E> Gaussian binomial </E> is
<Display> \begin{bmatrix} n \\ k \end{bmatrix} = \frac{[n]!}{[k]![n-k]!}.</Display>
 
</Section>

<Section Label="sec2.2"> <Heading>Quantized enveloping algebras</Heading>

Let <Math>\mathfrak{g}</Math> be a semisimple Lie algebra with root system <Math>\Phi</Math>. 
By <Math>\Delta=\{\alpha_1,\ldots, \alpha_l \}</Math> we denote a fixed simple system 
of <Math>\Phi</Math>. Let <Math>C=(C_{ij})</Math> be the Cartan matrix of <Math>\Phi</Math> (with respect to 
<Math>\Delta</Math>, i.e., <Math> C_{ij} = \langle \alpha_i, \alpha_j^{\vee} \rangle</Math>). 
Let <Math>d_1,\ldots, d_l</Math> be the unique sequence of positive integers with 
greatest common divisor <Math>1</Math>, such that <Math> d_i C_{ji} = d_j C_{ij} </Math>, and set 
<Math> (\alpha_i,\alpha_j) = d_j C_{ij} </Math>. (We note that this implies that 
<Math>(\alpha_i,\alpha_i)</Math> is divisible by <Math>2</Math>.) By <Math>P</Math> we denote the weight 
lattice, and we extend the form <Math>(~,~)</Math> to <Math>P</Math> by bilinearity. <P/> 
By <Math>W(\Phi)</Math> we denote the Weyl group of <Math>\Phi</Math>. It is generated by the 
simple reflections <Math>s_i=s_{\alpha_i}</Math> for <Math>1\leq i\leq l</Math> (where 
<Math>s_{\alpha}</Math> is defined by <Math>s_{\alpha}(\beta) = \beta - \langle\beta, 
\alpha^{\vee}\rangle \alpha</Math>).<P/> 
We work over the field <Math>\mathbb{Q}(q)</Math>. For <Math>\alpha\in\Phi </Math> we set
<Display> q_{\alpha} = q^{\frac{(\alpha,\alpha)}{2}},</Display>
and for a non-negative integer <Math>n</Math>, <Math>[n]_{\alpha}= [n]_{v=q_{\alpha}}</Math>; 
<Math>[n]_{\alpha}!</Math> and <Math>\begin{bmatrix} n \\ k \end{bmatrix}_{\alpha}</Math> are 
defined analogously.<P/> 
The quantized enveloping algebra <Math>U_q(\mathfrak{g})</Math> is the associative 
algebra (with one) over <Math>\mathbb{Q}(q)</Math> generated by <Math>F_{\alpha}</Math>, 
<Math>K_{\alpha}</Math>, <Math>K_{\alpha}^{-1}</Math>, <Math>E_{\alpha}</Math> for <Math>\alpha\in\Delta</Math>, 
subject to the following relations 
<Display>
\begin{aligned} 
K_{\alpha}K_{\alpha}^{-1} &amp;= K_{\alpha}^{-1}K_{\alpha} = 1,~ 
K_{\alpha}K_{\beta} = K_{\beta}K_{\alpha}\\ 
E_{\beta} K_{\alpha} &amp;= q^{-(\alpha,\beta)}K_{\alpha} E_{\beta}\\ 
K_{\alpha} F_{\beta} &amp;= q^{-(\alpha,\beta)}F_{\beta}K_{\alpha}\\ 
E_{\alpha} F_{\beta} &amp;= F_{\beta}E_{\alpha} +\delta_{\alpha,\beta} 
\frac{K_{\alpha}-K_{\alpha}^{-1}}{q_{\alpha}-q_{\alpha}^{-1}} 
\end{aligned}
</Display> 
together with, for <Math>\alpha\neq \beta\in\Delta</Math>, 
<Display>
\begin{aligned} 
\sum_{k=0}^{1-\langle \beta,\alpha^{\vee}\rangle } 
(-1)^k \begin{bmatrix} 1-\langle \beta,\alpha^{\vee}\rangle \\ k 
\end{bmatrix}_{\alpha} E_{\alpha}^{1-\langle \beta,\alpha^{\vee}\rangle-k} 
E_{\beta} E_{\alpha}^k =0 &amp; \\ 
\sum_{k=0}^{1-\langle \beta,\alpha^{\vee}\rangle } (-1)^k \begin{bmatrix} 
1-\langle \beta,\alpha^{\vee}\rangle \\ k \end{bmatrix}_{\alpha} 
F_{\alpha}^{1-\langle \beta,\alpha^{\vee}\rangle-k} 
F_{\beta} F_{\alpha}^k =0 &amp;. 
\end{aligned}
</Display> 
The quantized enveloping algebra has an automorphism <Math>\omega</Math> defined by 
<Math>\omega( F_{\alpha} ) = E_{\alpha}</Math>, <Math>\omega(E_{\alpha})= F_{\alpha}</Math> and 
<Math>\omega(K_{\alpha})=K_{\alpha}^{-1}</Math>. Also there is an anti-automorphism 
<Math>\tau</Math> defined by <Math>\tau(F_{\alpha})=F_{\alpha}</Math>, <Math>\tau(E_{\alpha})=
E_{\alpha}</Math> and <Math>\tau(K_{\alpha})=K_{\alpha}^{-1}</Math>. We have <Math>\omega^2=1</Math> 
and <Math>\tau^2=1</Math>.<P/> 
If the Dynkin diagram of <Math>\Phi</Math> admits a diagram automorphism <Math>\pi</Math>, then 
<Math>\pi</Math> induces an automorphism of <Math>U_q(\mathfrak{g})</Math> in the obvious way 
(<Math>\pi</Math> is a permutation of the simple roots; we permute the <Math>F_{\alpha}</Math>, 
<Math>E_{\alpha}</Math>, <Math>K_{\alpha}^{\pm 1}</Math> accordingly).<P/> 
Now we view <Math>U_q(\mathfrak{g})</Math> as an algebra over <Math>\mathbb{Q}</Math>, and we let 
<Math>\overline{\phantom{A}} : U_q(\mathfrak{g})\to U_q(\mathfrak{g})</Math> be the 
automorphism defined by <Math>\overline{F_{\alpha}}=F_{\alpha}</Math>, 
<Math>\overline{K_{\alpha}}= K_{\alpha}^{-1}</Math>, <Math>\overline{E_{\alpha}}=E_{\alpha}</Math>,
 <Math>\overline{q}=q^{-1}</Math>.

</Section>

<Section Label="sec2.3"> <Heading>Representations of <Math>U_q(\mathfrak{g})</Math>  </Heading>

Let <Math>\lambda\in P</Math> be a dominant weight. Then there is a unique irreducible 
highest-weight module over <Math>U_q(\mathfrak{g})</Math> with highest weight <Math>\lambda</Math>. 
We denote it by <Math>V(\lambda)</Math>. It has the same character as the irreducible 
highest-weight module over <Math>\mathfrak{g}</Math> with highest weight <Math>\lambda</Math>. 
Furthermore, every finite-dimensional <Math>U_q(\mathfrak{g})</Math>-module is a direct 
sum of irreducible highest-weight modules.<P/> 
It is well-known that <Math>U_q(\mathfrak{g})</Math> is a Hopf algebra. The 
comultiplication <Math>\Delta : U_q(\mathfrak{g})\to U_q(\mathfrak{g})
\otimes U_q(\mathfrak{g})</Math> is defined by 
<Display> \begin{aligned} 
\Delta(E_{\alpha}) &amp;= E_{\alpha}\otimes 1 + K_{\alpha}\otimes E_{\alpha}\\
\Delta(F_{\alpha}) &amp;= F_{\alpha}\otimes K_{\alpha}^{-1} + 
1\otimes F_{\alpha}\\ 
\Delta(K_{\alpha}) &amp;= K_{\alpha}\otimes K_{\alpha}.
\end{aligned} </Display> 
(Note that we use the same symbol to denote a simple system of <Math>\Phi</Math>; of 
course this does not cause confusion.) The counit <Math>\varepsilon : 
U_q(\mathfrak{g}) \to \mathbb{Q}(q)</Math> is a homomorphism defined by 
<Math>\varepsilon(E_{\alpha})=\varepsilon(F_{\alpha})=0</Math>, 
<Math>\varepsilon( K_{\alpha}) =1</Math>. Finally, the antipode 
<Math>S: U_q(\mathfrak{g})\to U_q(\mathfrak{g})</Math> is an anti-automorphism given 
by <Math>S(E_{\alpha})=-K_{\alpha}^{-1}E_{\alpha}</Math>, <Math>S(F_{\alpha})=-F_{\alpha}
K_{\alpha}</Math>, <Math>S(K_{\alpha})=K_{\alpha}^{-1}</Math>.<P/> 
Using <Math>\Delta</Math> we can make the tensor product <Math>V\otimes W</Math> of two 
<Math>U_q(\mathfrak{g})</Math>-modules <Math>V,W</Math> into a <Math>U_q(\mathfrak{g})</Math>-module. 
The counit <Math>\varepsilon</Math> yields a trivial <Math>1</Math>-dimensional 
<Math>U_q(\mathfrak{g})</Math>-module. And with <Math>S</Math> we can define a 
<Math>U_q(\mathfrak{g})</Math>-module structure on the dual <Math>V^*</Math> of a 
<Math>U_q(\mathfrak{g})</Math>-module <Math>V</Math>, by <Math>(u\cdot f)(v) = f(S(u)\cdot v )</Math>.<P/> 
The Hopf algebra structure given above is not the only one possible. For 
example, we can twist <Math>\Delta,\varepsilon,S</Math> by an automorphism, or an 
anti-automorphism <Math>f</Math>. The twisted comultiplication is given by 
<Display>\Delta^f = f\otimes f \circ\Delta\circ f^{-1}.</Display> 
The twisted antipode by 
<Display> S^f = \begin{cases} f\circ S\circ f^{-1} &amp; \text{ if }f\text{ is an
automorphism}\\ f\circ S^{-1}\circ f^{-1}
&amp; \text{ if }f\text{ is an anti-automorphism.}\end{cases}</Display>
And the twisted counit by <Math>\varepsilon^f = \varepsilon\circ f^{-1}</Math> 
(see <Cite Key="J96"/>, 3.8).

</Section>

<Section Label="sec2.4"> <Heading>PBW-type bases </Heading>

The first problem one has to deal with when working with <Math>U_q(\mathfrak{g})</Math> 
is finding a basis of it, along with an algorithm for expressing the product 
of two basis elements as a linear combination of basis elements. 
First of all we have that <Math>U_q(\mathfrak{g})\cong U^-\otimes U^0\otimes U^+</Math> 
(as vector spaces), where <Math>U^-</Math> is the subalgebra generated by the 
<Math>F_{\alpha}</Math>, <Math>U^0</Math> is the subalgebra generated by the <Math>K_{\alpha}</Math>, and 
<Math>U^+</Math> is generated by the <Math>E_{\alpha}</Math>. So a basis of <Math>U_q(\mathfrak{g})</Math> is 
formed by all elements <Math>FKE</Math>, where <Math>F</Math>, <Math>K</Math>, <Math>E</Math> run through bases of <Math>U^-</Math>, 
<Math>U^0</Math>, <Math>U^+</Math> respectively.<P/> 
Finding a basis of <Math>U^0</Math> is easy: it is spanned by all <Math>K_{\alpha_1}^{r_1} 
\cdots K_{\alpha_l}^{r_l}</Math>, where <Math>r_i\in\mathbb{Z}</Math>. For <Math>U^-</Math>, <Math>U^+</Math> we 
use the so-called <E>PBW-type</E> bases. They are defined as follows. 
For <Math>\alpha,\beta\in\Delta</Math> we set <Math>r_{\beta,\alpha} = -\langle \beta,
\alpha^{\vee}\rangle</Math>. Then for <Math>\alpha\in\Delta</Math> we have the automorphism 
<Math>T_{\alpha} : U_q(\mathfrak{g})\to U_q(\mathfrak{g})</Math> defined by 
<Display> \begin{aligned} 
T_{\alpha}(E_{\alpha}) &amp;= -F_{\alpha}K_{\alpha}\\ 
T_{\alpha}(E_{\beta}) &amp;= \sum_{i=0}^{r_{\beta,\alpha}} 
(-1)^i q_{\alpha}^{-i} E_{\alpha}^{(r_{\beta,\alpha}-i)}E_{\beta}
E_{\alpha}^{(i)}\text{ if } \alpha\neq\beta \\
T_{\alpha}(K_{\beta}) &amp;= K_{\beta}K_{\alpha}^{r_{\beta,\alpha}}\\ 
T_{\alpha}(F_{\alpha}) &amp;= -K_{\alpha}^{-1} E_{\alpha}\\ 
T_{\alpha}(F_{\beta}) &amp;= \sum_{i=0}^{r_{\beta,\alpha}} 
(-1)^i q_{\alpha}^{i} F_{\alpha}^{(i)}F_{\beta}F_{\alpha}^ 
{(r_{\beta,\alpha}-i)}\text{ if }\alpha\neq\beta,\\ 
\end{aligned} </Display>
(where <Math>E_{\alpha}^{(k)} = E_{\alpha}^k/[k]_{\alpha}!</Math>, and likewise for 
<Math>F_{\alpha}^{(k)}</Math>). <P/> 
Let <Math>w_0=s_{i_1}\cdots s_{i_t}</Math> be a reduced expression for the longest 
element in the Weyl group <Math>W(\Phi)</Math>. For <Math>1\leq k\leq t</Math> set 
<Math>F_k = T_{\alpha_{i_1}}\cdots T_{\alpha_{i_{k-1}}}(F_{\alpha_{i_k}})</Math>, 
and <Math>E_k = T_{\alpha_{i_1}}\cdots T_{\alpha_{i_{k-1}}}(E_{\alpha_{i_k}})</Math>. 
Then <Math>F_k\in U^-</Math>, and <Math>E_k\in U^+</Math>. Furthermore, the elements <Math>F_1^{m_1}
\cdots F_t^{m_t}</Math>, <Math>E_1^{n_1}\cdots E_t^{n_t}</Math> (where the <Math>m_i</Math>, <Math>n_i</Math> 
are non-negative integers) form bases of <Math>U^-</Math> and <Math>U^+</Math> respectively. <P/> 
The elements <Math>F_{\alpha}</Math> and <Math>E_{\alpha}</Math> are said to have weight 
<Math>-\alpha</Math> and <Math>\alpha</Math> respectively, where <Math>\alpha</Math> is a simple root. 
Furthermore, the weight of a product <Math>ab</Math> is the sum of the weights of <Math>a</Math> 
and <Math>b</Math>. Now elements of <Math>U^-</Math>, <Math>U^+</Math> that are linear combinations of elements
of the same weight are said to be homogeneous. It can be shown that the 
elements <Math>F_k</Math>, and <Math>E_k</Math> are homogeneous of weight <Math>-\beta</Math> and <Math>\beta</Math> 
respectively, where <Math>\beta=s_{i_1}\cdots s_{i_{k-1}}(\alpha_{i_k})</Math>. <P/> 
In the sequel we use the notation <Math>F_k^{(m)} = F_k^m/[m]_{\alpha_{i_k}}!</Math>, 
and <Math>E_k^{(n)} = E_k^n/[n]_{\alpha_{i_k}}!</Math>. <P/>

</Section>

<Section Label="sec2.5"> <Heading>The <Math>{\mathbb Z}</Math>-form of <Math>U_q(\mathfrak{g})</Math> </Heading>

For <Math>\alpha\in\Delta</Math> set 
<Display>\begin{bmatrix} K_{\alpha} \\ n \end{bmatrix} = \prod_{i=1}^n 
\frac{q_{\alpha}^{-i+1}K_{\alpha} - q_{\alpha}^{i-1} K_{\alpha}^{-1}}
{q_{\alpha}^i-q_{\alpha}^{-i}}.</Display> 
Then according to <Cite Key="L90"/>, Theorem 6.7 the elements 
<Display>F_1^{(k_1)}\cdots F_t^{(k_t)} K_{\alpha_1}^{\delta_1} 
\begin{bmatrix} K_{\alpha_1} \\ m_1 \end{bmatrix} 
\cdots K_{\alpha_l}^{\delta_l}
\begin{bmatrix} K_{\alpha_l} \\ m_l \end{bmatrix} 
E_1^{(n_1)}\cdots E_t^{(n_t)},</Display> 
(where <Math>k_i,m_i,n_i\geq 0</Math>, <Math>\delta_i=0,1</Math>) form a basis of 
<Math>U_q(\mathfrak{g})</Math>, such that the product of any two basis elements is a 
linear combination of basis elements with coefficients in 
<Math>\mathbb{Z}[q,q^{-1}]</Math>. The quantized enveloping algebra over 
<Math>\mathbb{Z}[q,q^{-1}]</Math> with this basis is called the <Math>\mathbb{Z}</Math>-form of 
<Math>U_q(\mathfrak{g})</Math>, and denoted by <Math>U_{\mathbb{Z}}</Math>. Since <Math>U_{\mathbb{Z}}</Math> 
is defined over <Math>\mathbb{Z}[q,q^{-1}]</Math> we can specialize <Math>q</Math> to any nonzero 
element <Math>\epsilon</Math> of a field <Math>F</Math>, and obtain an algebra <Math>U_{\epsilon}</Math> over 
<Math>F</Math>. <P/> 
We call <Math>q\in \mathbb{Q}(q)</Math>, and <Math>\epsilon \in F</Math> the quantum parameter of 
<Math>U_q(\mathfrak{g})</Math> and <Math>U_{\epsilon}</Math> respectively. <P/> 
Let <Math>\lambda</Math> be a dominant weight, and <Math>V(\lambda)</Math> the irreducible highest 
weight module of highest weight <Math>\lambda</Math> over <Math>U_q(\mathfrak{g})</Math>. Let 
<Math>v_{\lambda}\in V(\lambda)</Math> be a fixed highest weight vector. Then 
<Math>U_{\mathbb{Z}}\cdot v_{\lambda}</Math> is a <Math>U_{\mathbb{Z}}</Math>-module. So by 
specializing <Math>q</Math> to an element <Math>\epsilon</Math> of a field <Math>F</Math>, we get a 
<Math>U_{\epsilon}</Math>-module. We call it the Weyl module of highest weight <Math>\lambda</Math> 
over <Math>U_{\epsilon}</Math>. We note that it is not necessarily irreducible.

</Section>

<Section Label="sec2.6"> <Heading>The canonical basis </Heading>

As in Section <Ref Sect="sec2.4"/> we let <Math>U^-</Math> be the subalgebra of 
<Math>U_q(\mathfrak{g})</Math> generated by the <Math>F_{\alpha}</Math> for <Math>\alpha\in\Delta</Math>. 
In <Cite Key="L0a"/> Lusztig 
introduced a basis of <Math>U^-</Math> with very nice properties, 
called the <E>canonical basis</E>. (Later this basis was also constructed
by Kashiwara, using a different method. For a brief overview on the history of
canonical bases we refer to <Cite Key="C06"/>.) <P/> 
Let <Math>w_0=s_{i_1}\cdots s_{i_t}</Math>, and the elements <Math>F_k</Math> be as in Section 
<Ref Sect="sec2.4"/>. Then, in order to stress the dependency of the monomial
<Display>
F_1^{(n_1)}\cdots F_t^{(n_t)} 
</Display> 
on the choice of reduced expression for the longest element in <Math>W(\Phi)</Math> we 
say that it is a <Math>w_0</Math>-monomial.<P/> 
Now we let <Math>\overline{\phantom{a}}</Math> be the automorphism of <Math>U^-</Math> defined in 
Section <Ref Sect="sec2.2"/>. Elements that are invariant under 
<Math>\overline{\phantom{a}}</Math> are said to be bar-invariant. <P/> 
By results of Lusztig (<Cite Key="L93"/> Theorem 42.1.10, 
<Cite Key="L96"/>, Proposition 8.2), there is a unique basis 
<Math>{\bf B}</Math> of <Math>U^-</Math> with the following properties. Firstly, all elements of 
<Math>{\bf B}</Math> are bar-invariant. Secondly, for any choice of reduced expression 
<Math>w_0</Math> for the longest element in the Weyl group, and any element <Math>X\in{\bf B}</Math> 
we have that <Math>X = x +\sum \zeta_i x_i</Math>, where <Math>x,x_i</Math> are <Math>w_0</Math>-monomials, 
<Math>x\neq x_i</Math> for all <Math>i</Math>, and <Math>\zeta_i\in q\mathbb{Z}[q]</Math>. The basis <Math>{\bf B}</Math> 
is called the canonical basis. If we work with a fixed reduced expression 
for the longest element in <Math>W(\Phi)</Math>, and write <Math>X\in{\bf B}</Math> as above, 
then we say that <Math>x</Math> is the <E>principal monomial</E> of <Math>X</Math>.<P/> 
Let <Math>\mathcal{L}</Math> be the <Math>\mathbb{Z}[q]</Math>-lattice in <Math>U^-</Math> spanned by <Math>{\bf B}</Math>. 
Then <Math>\mathcal{L}</Math> is also spanned by all <Math>w_0</Math>-monomials (where <Math>w_0</Math> is 
a fixed reduced expression for the longest element in <Math>W(\Phi)</Math>). Now 
let <Math>\widetilde{w}_0</Math> be a second reduced expression for the longest element 
in <Math>W(\Phi)</Math>. Let <Math>x</Math> be a <Math>w_0</Math>-monomial, and let <Math>X</Math> be the element of 
<Math>{\bf B}</Math> with principal monomial <Math>x</Math>. Write <Math>X</Math> as a linear combination of 
<Math>\widetilde{w}_0</Math>-monomials, and let <Math>\widetilde{x}</Math> be the principal monomial 
of that expression. Then we write <Math>\widetilde{x} = R_{w_0}^{\tilde{w}_0}(x)</Math>. 
Note that <Math>x = \widetilde{x} \bmod q\mathcal{L}</Math>. <P/> 
Now let <Math>\mathcal{B}</Math> be the set of all <Math>w_0</Math>-monomials <Math>\bmod q\mathcal{L}</Math>. 
Then <Math>\mathcal{B}</Math> is a basis of the <Math>\mathbb{Z}</Math>-module 
<Math>\mathcal{L}/q\mathcal{L}</Math>. Moreover, <Math>\mathcal{B}</Math> is independent of the 
choice of <Math>w_0</Math>. Let <Math>\alpha\in\Delta</Math>, and let <Math>\widetilde{w}_0</Math> be a 
reduced expression for the longest element in <Math>W(\Phi)</Math>, starting with 
<Math>s_{\alpha}</Math>. The Kashiwara operators <Math>\widetilde{F}_{ \alpha} : 
\mathcal{B}\to \mathcal{B}</Math> and <Math>\widetilde{E}_{\alpha} : \mathcal{B}\to 
\mathcal{B}\cup\{0\}</Math> are defined as follows. Let <Math>b\in\mathcal{B}</Math> and 
let <Math>x=</Math>
be the <Math>w_0</Math>-monomial such that <Math>b = x \bmod q\mathcal{L}</Math>. Set 
<Math>\widetilde{x} = R_{w_0}^ {\tilde{w}_0}(x)</Math>. Then <Math>\widetilde{x}'</Math> is the 
<Math>\widetilde{w}_0</Math>-monomial constructed from <Math>\widetilde{x}</Math> by increasing 
its first exponent by <Math>1</Math> (the first exponent is <Math>n_1</Math> if we write
<Math>\widetilde{x}=F_1^{(n_1)}\cdots F_t^{(n_t)}</Math>). 
Then <Math>\widetilde{F}_{ \alpha}(b) = R_{\tilde{w}_0}^{w_0}(\widetilde{x}') 
\bmod q\mathcal{L}</Math>. For <Math>\widetilde{E}_{\alpha}</Math> we let <Math>\widetilde{x}'</Math> 
be the <Math>\widetilde{w}_0</Math>-monomial constructed from <Math>\widetilde{x}</Math> by 
decreasing its first exponent by <Math>1</Math>, if this exponent is <Math>\geq 1</Math>. Then 
<Math>\widetilde{E}_{\alpha}(b) = R_{\tilde{w}_0}^{w_0}(\widetilde{x}')\bmod 
q\mathcal{L}</Math>. Furthermore, <Math>\widetilde{E}_{\alpha}(b) =0</Math> if the first 
exponent of <Math>\widetilde{x}</Math> is <Math>0</Math>. It can be shown that this definition does 
not depend on the choice of <Math>w_0</Math>, <Math>\widetilde{w}_0</Math>. Furthermore we have 
<Math>\widetilde{F}_{\alpha}\widetilde{E}_{\alpha}(b)=b</Math>, if 
<Math>\widetilde{E}_{\alpha}(b)\neq 0</Math>, and <Math>\widetilde{E}_{\alpha}
\widetilde{F}_ {\alpha}(b)=b</Math> for all <Math>b\in \mathcal{B}</Math>.<P/> 
Let <Math>w_0=s_{i_1}\cdots s_{i_t}</Math> be a fixed reduced expression for the 
longest element in <Math>W(\Phi)</Math>. For <Math>b\in\mathcal{B}</Math> we define a sequence of 
elements <Math>b_k\in\mathcal{B}</Math> for <Math>0\leq k\leq t</Math>, and a sequence of integers 
<Math>n_k</Math> for <Math>1\leq k\leq t</Math> as follows. We set <Math>b_0=b</Math>, and if <Math>b_{k-1}</Math> is 
defined we let <Math>n_k</Math> be maximal such that <Math>\widetilde{E}_{\alpha_{i_k}}^ 
{n_k}(b_{k-1})\neq 0</Math>. Also we set <Math>b_k = \widetilde{E}_{\alpha_{i_k}}^{n_k} 
(b_{k-1})</Math>. Then the sequence <Math>(n_1,\ldots,n_t)</Math> is called the <E>string</E> 
of <Math>b\in\mathcal{B}</Math> (relative to <Math>w_0</Math>). We note that 
<Math>b=\widetilde{F}_ {\alpha_{i_1}}^{n_1}\cdots \widetilde{F}_{\alpha_{i_t}}^
{n_t}(1)</Math>. The set of all strings parametrizes the elements of <Math>\mathcal{B}</Math>, 
and hence of <Math>{\bf B}</Math>.<P/> 
Now let <Math>V(\lambda)</Math> be a highest-weight module over <Math>U_q(\mathfrak{g})</Math>, 
with highest weight <Math>\lambda</Math>. Let <Math>v_{\lambda}</Math> be a fixed highest weight 
vector. Then <Math>{\bf B}_{\lambda} = \{ X\cdot v_{\lambda}\mid X\in {\bf B}\} 
\setminus \{0\}</Math> is a basis of <Math>V(\lambda)</Math>, called the <E>canonical basis</E>, 
or <E>crystal basis</E> of <Math>V(\lambda)</Math>. Let <Math>\mathcal{L}(\lambda)</Math> be the 
<Math>\mathbb{Z}[q]</Math>-lattice in <Math>V(\lambda)</Math> spanned by <Math>{\bf B}_{\lambda}</Math>. We 
let <Math>\mathcal{B}({\lambda})</Math> be the set of all <Math>x\cdot v_{\lambda}\bmod 
q\mathcal{L}(\lambda)</Math>, where <Math>x</Math> runs through all <Math>w_0</Math>-monomials, such 
that <Math>X\cdot v_{\lambda} \neq 0</Math>, where <Math>X\in {\bf B}</Math> is the element with 
principal monomial <Math>x</Math>. Then the Kashiwara operators are also viewed as 
maps <Math>\mathcal{B}(\lambda)\to \mathcal{B}(\lambda)\cup\{0\}</Math>, in the following 
way. Let <Math>b=x\cdot v_{\lambda}\bmod q\mathcal{L}(\lambda)</Math> be an element 
of <Math>\mathcal{B}(\lambda)</Math>, and let <Math>b'=x\bmod q\mathcal{L}</Math> be the 
corresponding element of <Math>\mathcal{B}</Math>. Let <Math>y</Math> be the <Math>w_0</Math>-monomial such 
that <Math>\widetilde{F}_{\alpha}(b')=y\bmod q\mathcal{L}</Math>. Then 
<Math>\widetilde{F}_{ \alpha}(b) = y\cdot v_{\lambda} \bmod q\mathcal{L}(\lambda)</Math>. 
The description of <Math>\widetilde{E}_{\alpha}</Math> is analogous. (In 
<Cite Key="J96"/>, Chapter 9 a different definition is given; however, by 
<Cite Key="J96"/>, Proposition 10.9, Lemma 10.13, the two definitions 
agree).<P/> 
The set <Math>\mathcal{B}(\lambda)</Math> has <Math>\dim V(\lambda)</Math> elements. We let 
<Math>\Gamma</Math> be the coloured directed graph defined as follows. The points of 
<Math>\Gamma</Math> are the elements of <Math>\mathcal{B}(\lambda)</Math>, and there is an arrow 
with colour <Math>\alpha\in\Delta</Math> connecting <Math>b,b'\in \mathcal{B}</Math>, if 
<Math>\widetilde{F}_{\alpha}(b)=b'</Math>. The graph <Math>\Gamma</Math> is called the 
<E>crystal graph</E> of <Math>V(\lambda)</Math>. 

</Section>

<Section Label="sec2.7"> <Heading> The path model </Heading>

In this section we recall some basic facts on Littelmann's path model. <P/> 
From Section <Ref Sect="sec2.2"/> we recall that <Math>P</Math> denotes the weight 
lattice. Let <Math>P_{\mathbb{R}}</Math> be the vector space over <Math>\mathbb{R}</Math> spanned 
by <Math>P</Math>. Let <Math>\Pi</Math> be the set of all piecewise linear paths 
<Math>\xi : [0,1]\to P_{\mathbb{R}} </Math>, such that <Math>\xi(0)=0</Math>. For <Math>\alpha\in\Delta</Math> 
Littelmann defined operators <Math>f_{\alpha}, e_{\alpha} : \Pi \to \Pi\cup \{0\}</Math>. 
Let <Math>\lambda</Math> be a dominant weight and let <Math>\xi_{\lambda}</Math> be the path joining 
<Math>\lambda</Math> and the origin by a straight line. Let <Math>\Pi_{\lambda}</Math> be the set 
of all nonzero <Math>f_{\alpha_{i_1}}\cdots f_{\alpha_{i_m}}(\xi_{\lambda})</Math> for 
<Math>m\geq 0</Math>. Then <Math>\xi(1)\in P</Math> for all <Math>\xi\in \Pi_{\lambda}</Math>. Let <Math>\mu\in P</Math> 
be a weight, and let <Math>V(\lambda)</Math> be the highest-weight module over 
<Math>U_q(\mathfrak{g})</Math> of highest weight <Math>\lambda</Math>. A theorem of Littelmann 
states that the number of paths <Math>\xi\in \Pi_{\lambda}</Math> such that <Math>\xi(1)=\mu</Math> 
is equal to the dimension of the weight space of weight <Math>\mu</Math> in <Math>V(\lambda)</Math> 
(<Cite Key="L95"/>, Theorem 9.1).<P/> 
All paths appearing in <Math>\Pi_{\lambda}</Math> are so-called Lakshmibai-Seshadri 
paths (LS-paths for short). They are defined as follows. Let <Math>\leq</Math> denote 
the Bruhat order on <Math>W(\Phi)</Math>. For <Math>\mu,\nu\in W(\Phi)\cdot \lambda</Math> (the 
orbit of <Math>\lambda</Math> under the action of <Math>W(\Phi)</Math>), write <Math>\mu\leq \nu</Math> if 
<Math>\tau\leq\sigma</Math>, where <Math>\tau,\sigma\in W(\Phi)</Math> are the unique elements 
of minimal length such that <Math>\tau(\lambda)=\mu</Math>, <Math>\sigma(\lambda)= \nu</Math>. 
Now a rational path of shape <Math>\lambda</Math> is a pair <Math>\pi=(\nu,a)</Math>, where 
<Math>\nu=(\nu_1,\ldots, \nu_s)</Math> is a sequence of elements of <Math>W(\Phi)\cdot 
\lambda</Math>, such that <Math>\nu_i> \nu_{i+1}</Math> and <Math>a=(a_0=0, a_1, \cdots ,a_s=1)</Math> 
is a sequence of rationals such that <Math>a_i &lt;a_{i+1}</Math>. The path <Math>\pi</Math> 
corresponding to these sequences is given by 
<Display> \pi(t) =\sum_{j=1}^{r-1} (a_j-a_{j-1})\nu_j + \nu_r(t-a_{r-1})</Display> 
for <Math>a_{r-1}\leq t\leq a_r</Math>. Now an LS-path of shape <Math>\lambda</Math> is a rational 
path satisfying a certain integrality condition (see 
<Cite Key="L94"/>, <Cite Key="L95"/>). We note that the path <Math>\xi_{\lambda} 
= ( (\lambda), (0,1) )</Math> joining the origin and <Math>\lambda</Math> by a straight line 
is an LS-path.<P/> 
Now from <Cite Key="L94"/>, <Cite Key="L95"/> we transcribe the following: 
<Enum> 
<Item> Let <Math>\pi</Math> be an LS-path. Then <Math>f_{\alpha}\pi</Math> is an LS-path or <Math>0</Math>; 
and the same holds for <Math>e_{\alpha}\pi</Math>. </Item>
<Item> The action of <Math>f_{\alpha},e_{\alpha}</Math> can easily be described 
combinatorially (see <Cite Key="L94"/>). </Item> 
<Item> The endpoint of an LS-path is an integral weight. </Item> 
<Item> Let <Math>\pi=(\nu,a)</Math> be an LS-path. Then by <Math>\phi(\pi)</Math> we denote the 
unique element <Math>\sigma</Math> of <Math>W(\Phi)</Math> of shortest length such that 
<Math>\sigma(\lambda)=\nu_1</Math>. </Item>
</Enum>
Let <Math>\lambda</Math> be a dominant weight. Then we define a labeled directed graph 
<Math>\Gamma</Math> as follows. The points of <Math>\Gamma</Math> are the paths in <Math>\Pi_{\lambda}</Math>. 
There is an edge with label <Math>\alpha\in\Delta</Math> from <Math>\pi_1</Math> to <Math>\pi_2</Math> if 
<Math>f_{\alpha}\pi_1 =\pi_2</Math>. Now by <Cite Key="K96"/> this graph <Math>\Gamma</Math> is 
isomorphic to the crystal graph of the highest-weight module with highest 
weight <Math>\lambda</Math>. So the path model provides an efficient way of computing 
the crystal graph of a highest-weight module, without constructing the module 
first. Also we see that <Math>f_{\alpha_{i_1}}\cdots f_{\alpha_{i_r}}\xi_{\lambda}
=0</Math> is equivalent to <Math>\widetilde{F}_{\alpha_{i_1}}\cdots \widetilde{F}_ 
{\alpha_{i_r}}v_{\lambda}=0</Math>, where <Math>v_{\lambda}\in V(\lambda)</Math> is a 
highest weight vector (or rather the image of it in <Math>\mathcal{L}(\lambda)/
q\mathcal{L} (\lambda)</Math>), and the <Math>\widetilde{F}_{\alpha_k}</Math> are the 
Kashiwara operators on <Math>\mathcal{B}(\lambda)</Math> (see Section 
<Ref Sect="sec2.6"/>).

</Section>

<Section> <Heading> Notes</Heading>

I refer to <Cite Key="H90"/> for more information on Weyl groups, and to 
<Cite Key="S01"/> for an overview of algorithms for computing with weights, 
Weyl groups and their elements.<P/> 
For general introductions into the theory of quantized enveloping algebras I 
refer to <Cite Key="C98"/>, <Cite Key="J96"/> (from where most of the material 
of this chapter is taken), <Cite Key="L92"/>, <Cite Key="L93"/>, 
<Cite Key="R91"/>. I refer to the papers by Littelmann (<Cite Key="L94"/>, 
<Cite Key="L95"/>, <Cite Key="L98"/>) for more information on the path model. 
The paper by Kashiwara (<Cite Key="K96"/>) contains a proof of the connection 
between path operators and Kashiwara operators.<P/> 
Finally, I refer to <Cite Key="G01"/> (on computing with PBW-type bases), 
<Cite Key="G02"/> (computation of elements of the canonical basis) for an 
account of some of the algorithms used in <Package>QuaGroup</Package>.

</Section>

</Chapter>

<Chapter Label="chap3"> <Heading>QuaGroup</Heading>

In this chapter we describe the functionality provided by 
<Package>QuaGroup</Package>.

<Section Label="sec:globcst"> <Heading>Global constants</Heading>

<ManSection> 
        
<Var Name="QuantumField"/>
<Description>
This is the field <M>Q(q)</M> of rational functions in <M>q</M>,
over <M>Q</M>.
<Example><![CDATA[
gap> QuantumField;
QuantumField
]]></Example>
</Description>
</ManSection>
   
<ManSection> 
        
<Var Name="_q"/>
<Description>
This is an indeterminate; <A>QuantumField</A> is the field of rational 
functions in this  indeterminate. The identifier <A>&uscore;q</A> is fixed 
once the package <Package>QuaGroup</Package> is loaded.  The  symbol 
<A>&uscore;q</A> is chosen (instead of <A>q</A>) in order to avoid potential
name clashes. We note that <A>&uscore;q</A> is printed as <A>q</A>.
<Example><![CDATA[
gap> _q;
q
gap> _q in QuantumField;
true
]]></Example>
</Description>
</ManSection>

</Section>

    
<Section> <Heading>Gaussian integers</Heading>
      
<ManSection> 
        
<Oper Name="GaussNumber" Arg="n, par"/>
<Description>
This function computes for the integer <A>n</A> the Gaussian integer 
<M>[n]_{v=<A>par</A>}</M> (cf. Section <Ref Sect="sec2.1"/>).
<Example><![CDATA[
gap> GaussNumber( 4, _q );
q^3+q+q^-1+q^-3
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="GaussianFactorial" Arg="n, par"/>
<Description>
This function computes for the integer <A>n</A> the Gaussian factorial
<M>[n]!_{v=<A>par</A>}</M>.
<Example><![CDATA[
gap> GaussianFactorial( 3, _q );
q^3+2*q+2*q^-1+q^-3
gap> GaussianFactorial( 3, _q^2 );
q^6+2*q^2+2*q^-2+q^-6
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="GaussianBinomial" Arg="n, k, par"/>
<Description>
This  function  computes  for  two  integers <A>n</A> and <A>k</A> the 
Gaussian binomial <A>n</A> choose <A>k</A>, where the parameter <M>v</M> 
is replaced by <A>par</A>.
<Example><![CDATA[
gap> GaussianBinomial( 5, 2, _q^2 );
q^12+q^8+2*q^4+2+2*q^-4+q^-8+q^-12
]]></Example>
</Description>
</ManSection>

</Section>
  
<Section> <Heading>Roots and root systems</Heading>

In  this  section  we describe some functions for dealing with root systems.
These functions supplement the ones already present in the &GAP; library.

<ManSection> 
<Oper Name="RootSystem" Arg="type, rank"/>
<Oper Name="RootSystem" Arg="list" Label="RootSystemList"/>
<Description>
Here  <A>type</A>  is  a capital letter between <A>"A"</A> and <A>"G"</A>, 
and <A>rank</A> is a positive integer (<M>\geq 1</M> if <A>type="A"</A>, 
<M>\geq 2</M> if <A>type="B"</A>, <A>"C"</A>, <M>\geq 4</M> if 
<A>type="D"</A>, <M>6,7,8</M> if <A>type="E"</A>,  <M>4</M> if 
<A>type="F"</A>, and <M>2</M> if <A>type="G"</A>). This function returns 
the root system  of  type  <A>type</A>  and  rank <A>rank</A>. In the second 
form <A>list</A> is a list of types and ranks, e.g.,  
<A>[ "B", 2, "F", 4, "D", 7 ]</A>. <P/>
The root system constructed by this function comes with he attributes
<A>PositiveRoots</A>, <A>NegativeRoots</A>, <A>SimpleSystem</A>, 
<A>CartanMatrix</A>, <A>BilinearFormMat</A>. Here the attribute 
<A>SimpleSystem</A> contains a set of simple roots, written as
unit vectors. <A>PositiveRoots</A> is a list of the positive roots, written as
linear combinations of the simple roots, and likewise for <A>NegativeRoots</A>.
<A>CartanMatrix( R )</A> is the Cartan matrix of the root system <A>R</A>, 
where the entry on position <M>( i, j )</M> is given by <M>\langle \alpha_i, 
\alpha_j^{\vee}\rangle</M> where <M>\alpha_i</M> is the <M>i</M>-th simple root. 
<A>BilinearFormMat( R )</A> is the matrix of the bilinear form,
where the entry on position <M>( i, j )</M> is given by <M>( \alpha_i, 
\alpha_j )</M> (see Section <Ref Sect="sec2.2"/>).<P/>
<A>WeylGroup( R )</A> returns the Weyl group of the root system <A>R</A>. 
We refer to the &GAP; reference manual for an overview of the functions for 
Weyl groups in the &GAP; library. We mention the functions 
<A>ConjugateDominantWeight( W, wt )</A> (returns the dominant weight in the 
<A>W</A>-orbit of the weight <A>wt</A>), and <A>WeylOrbitIterator( W, wt )</A>
(returns an iterator for the <A>W</A>-orbit containing the weight <A>wt</A>). 
We write weights as integral linear combinations of fundamental weights, so 
in &GAP; weights are represented by lists of integers
(of length equal to the rank of the root system). <P/>
Also we mention the function <A>PositiveRootsAsWeights( R )</A> that returns 
the positive roots of <A>R</A> written as weights, i.e., as linear 
combinations of the fundamental weights.
<Example><![CDATA[
gap> R:=RootSystem( [ "B", 2, "F", 4, "E", 6 ] );
<root system of type B2 F4 E6>
gap> R:= RootSystem( "A", 2 );
<root system of type A2>
gap> PositiveRoots( R );
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ]
gap> BilinearFormMat( R );
[ [ 2, -1 ], [ -1, 2 ] ]
gap> W:= WeylGroup( R );
Group([ [ [ -1, 1 ], [ 0, 1 ] ], [ [ 1, 0 ], [ 1, -1 ] ] ])
gap> ConjugateDominantWeight( W, [-3,2] );
[ 2, 1 ]
gap> o:= WeylOrbitIterator( W, [-3,2] );
<iterator>
gap> # Using the iterator we can loop over the orbit:
gap> NextIterator( o );
[ 2, 1 ]
gap> NextIterator( o );
[ -1, -2 ]
gap> PositiveRootsAsWeights( R );
[ [ 2, -1 ], [ -1, 2 ], [ 1, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="BilinearFormMatNF" Arg="R"/>
<Description>
This  is  the  matrix of the <Q>normalized</Q> bilinear form. This means 
that all diagonal  entries  are  even,  and  2  is the minimum value 
occurring on the diagonal. If <A>R</A> is a root system constructed by 
<Ref Oper="RootSystem"/>, then this is equal to <A>BilinearFormMat( R )</A>.
</Description>
</ManSection>

<ManSection>         
<Attr Name="PositiveRootsNF" Arg="R"/>
<Description>
This  is  the list of positive roots of the root system <A>R</A>, written 
as linear combinations  of the simple roots. This means that the simple roots 
are unit vectors. If <A>R</A> is a root system constructed by 
<Ref Oper="RootSystem"/>, then this is equal to <A>PositiveRoots( R )</A>. <P/>
One  of  the  reasons  for  writing  the  positive  roots  like  this is the
following.  Let  <A>a, b</A> be two elements of <A>PositiveRootsNF( R )</A>, 
and let <A>B</A> be the  matrix  of  the bilinear form. Then 
<A>a*( B*b )</A> is the result of applying the bilinear form to <A>a, b</A>.

<Example><![CDATA[
gap> R:= RootSystem( SimpleLieAlgebra( "B", 2, Rationals ) );;
gap> PositiveRootsNF( R );
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 1, 2 ] ]
gap> # We note that in this case PositiveRoots( R ) will give the
gap> # positive roots in a different format.
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="SimpleSystemNF" Arg="R"/>
<Description>
This  is  the list of simple roots of <A>R</A>, written as unit vectors 
(this means that  they  are  elements  of  <A>PositiveRootsNF(  R )</A>). 
If <A>R</A> is a root system constructed by <Ref Oper="RootSystem"/>, then 
this is equal to <A>SimpleSystem( R )</A>.
</Description>
</ManSection>

<ManSection>         
<Attr Name="PositiveRootsInConvexOrder" Arg="R"/>
<Description>
This  function  returns  the  positive  roots  of  the root system <A>R</A>, 
in the <Q>convex</Q>  order. Let <M>w_0=s_1\cdots s_t</M> be a reduced 
expression of the longest element  in  the  Weyl  group. Then the <M>k</M>-th 
element of the list returned by this function is <M>s_1\cdots s_{k-1}(\alpha_k)
</M>. (Where the reduced expression used is  the one returned by 
<A>LongestWeylWord( R )</A>.) If <M>\alpha</M>, <M>\beta</M> and 
<M>\alpha+\beta</M> are  positive  roots,  then <M>\alpha+\beta</M> occurs 
between <M>\alpha</M> and <M>\beta</M> (whence the name convex order).<P/>
In  the  output all roots are written in <Q>normal form</Q>, i.e., as 
elements of <A>PositiveRootsNF( R )</A>.

<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> PositiveRootsInConvexOrder( R );
[ [ 1, 0 ], [ 3, 1 ], [ 2, 1 ], [ 3, 2 ], [ 1, 1 ], [ 0, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="SimpleRootsAsWeights" Arg="R"/>
<Description>
Returns   the  simple  roots  of  the  root  system  <A>R</A>,  written  as  
linear combinations of the fundamental weights.
<Example><![CDATA[
gap> R:= RootSystem( "A", 2 );;
gap> SimpleRootsAsWeights( R );
[ [ 2, -1 ], [ -1, 2 ] ]
]]></Example>
</Description>
</ManSection>

</Section>

<Section> <Heading>Weyl groups and their elements</Heading>

Now  we  describe  a  few functions that deal with reduced words in the Weyl
group of the root system <A>R</A>. These words are represented as lists of 
positive integers <M>i</M>,  denoting  the  <M>i</M>-th simple reflection 
(which corresponds to the <M>i</M>-th element of <A>SimpleSystem( R )</A>). 
For example <A>[ 3, 2, 1, 3, 1 ]</A> represents
the expression <M>s_3 s_2 s_1 s_3 s_1</M>.

<ManSection>         
<Oper Name="ApplyWeylElement" Arg="W, wt, wd"/>
<Description>
Here <A>wd</A> is a (not necessarily reduced) word in the Weyl group <A>W</A>, 
and <A>wt</A> is a weight  (written as integral linear combination of the 
simple weights). This function returns the result of applying <A>wd</A> to 
<A>wt</A>. For example, if <A>wt=</A><M>\mu</M>, and
<A>wd = [ 1, 2 ]</A> then this function returns <M>s_1s_2(\mu)</M> (where 
<M>s_i</M> is the simple reflection corresponding to the <M>i</M>-th simple 
root).

<Example><![CDATA[
gap> W:= WeylGroup( RootSystem( "G", 2 ) ) ;;
gap> ApplyWeylElement( W, [ -3, 7 ], [ 1, 1, 2, 1, 2 ] );
[ 15, -11 ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="LengthOfWeylWord" Arg="W, wd"/>
<Description>
Here  <A>wd</A>  is a word in the Weyl group <A>W</A>. This function returns 
the length of that word.

<Example><![CDATA[
gap> W:= WeylGroup( RootSystem( "F", 4 ) ) ;
<matrix group with 4 generators>
gap> LengthOfWeylWord( W, [ 1, 3, 2, 4, 2 ] );
3
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="LongestWeylWord" Arg="R"/>
<Description>
Here  <A>R</A>  is  a root system. <A>LongestWeylWord( R )</A> returns the 
longest word in the Weyl group of <A>R</A>. <P/>
If this function is called for a root system <A>R</A>, a reduced expression 
for the longest  element  in  the  Weyl  group  is  calculated (the one which 
is the smallest  in  the  lexicographical  ordering). However, if you would 
like to work  with  a different reduced expression, then it is possible to 
set it by <A>SetLongestWeylWord( R, wd )</A>, where <A>wd</A> is a reduced 
expression of the longest element in the Weyl group. Note that you will have 
to do this before calling <A>LongestWeylWord</A>,  or  any  function  that 
may call <A>LongestWeylWord</A> (once the attribute  is set, it will not be 
possible to change it). Note also that you must  be sure that the word you 
give is in fact a reduced expression for the
longest  element  in  the  Weyl group, as this is not checked (you can check
this with <Ref Oper="LengthOfWeylWord"/>). <P/>
We  note  that  virtually  all  algorithms for quantized enveloping algebras
depend  on  the  choice of reduced expression for the longest element in the
Weyl group (as the PBW-type basis depends on this).

<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> LongestWeylWord( R );
[ 1, 2, 1, 2, 1, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="ReducedWordIterator" Arg="W, wd"/>
<Description>
Here  <A>W</A>  is  a  Weyl  group, and <A>wd</A> a reduced word. This 
function returns an iterator for the set of reduced words that represent the 
same element as <A>wd</A>. The elements are output in ascending 
lexicographical order.

<Example><![CDATA[
gap> R:= RootSystem( "F", 4 );;
gap> it:= ReducedWordIterator( WeylGroup(R), LongestWeylWord(R) );
<iterator>
gap> NextIterator( it );
[ 1, 2, 1, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4 ]
gap> k:= 1;;
gap> while not IsDoneIterator( it ) do
> k:= k+1; w:= NextIterator( it );
> od;
gap> k;
2144892
]]></Example>
So there are 2144892 reduced expressions for the longest element in the Weyl
group of type <M>F_4</M>.
</Description>
</ManSection>

<ManSection>         
<Oper Name="ExchangeElement" Arg="W, wd, ind"/>
<Description>
Here  <A>W</A>  is a Weyl group, and <A>wd</A> is a <E>reduced</E> word in 
<A>W</A>, and <A>ind</A> is an index between  1  and  the rank of the root 
system. Let <A>v</A> denote the word obtained from <A>wd</A> by adding 
<A>ind</A> at the end. This function <E>assumes</E> that the length of <A>v</A>
is  one  less  than the length of <A>wd</A>, and returns a reduced expression 
for <A>v</A> that is obtained from <A>wd</A> by deleting one entry. Nothing is 
guaranteed of the output if the length of <A>v</A> is bigger than the length 
of <A>wd</A>.

<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> wd:= LongestWeylWord( R );;
gap> ExchangeElement( WeylGroup(R), wd, 1 );
[ 2, 1, 2, 1, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="GetBraidRelations" Arg="W, wd1, wd2"/>
<Description>
Here  <A>W</A> is a Weyl group, and <A>wd1</A>, <A>wd2</A> are two reduced 
words representing the same  element in <A>W</A>. This function returns a 
list of braid relations that can be  applied  to <A>wd1</A> to obtain 
<A>wd2</A>. Here a braid relation is represented as a list, with at the odd 
positions integers that represent positions in a word,
and  at  the  even  positions  the indices that are on those positions after
applying  the relation. For example, let <A>wd</A> be the word 
<A>[ 1, 2, 1, 3, 2, 1 ]</A> and  let  <A>r = [ 3, 3, 4, 1 ]</A> be a relation. 
Then the result of applying <A>r</A> to <A>wd</A>  is  
<A>[ 1, 2, 3, 1, 2, 1]</A>  (i.e., on the third position we put a 3, and on
the fourth position a 1).<P/>
We  note that the function does not check first whether <A>wd1</A> and 
<A>wd2</A> represent the  same  element  in  <A>W</A>. If this is not the 
case, then an error will occur during the execution of the function, or it 
will produce wrong output.

<Example><![CDATA[
gap> R:= RootSystem( "A", 3 );;
gap> wd1:= LongestWeylWord( R );
[ 1, 2, 1, 3, 2, 1 ]
gap> wd2:= [ 1, 3, 2, 1, 3, 2 ];;
gap> GetBraidRelations( WeylGroup(R), wd1, wd2 );
[ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ], [ 4, 1, 5, 3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="LongWords" Arg="R"/>
<Description>
For  a  root system <A>R</A> this returns a list of triples (of length equal 
to the rank  of  <A>R</A>).  Let  <A>t</A>  be  the <A>k</A>-th triple 
occurring in this list. The first element  of  <A>t</A>  is  an expression 
for the longest element of the Weyl group, starting  with  <A>k</A>.  The  
second element is a list of braid relations, moving
this expression to the value of <A>LongestWeylWord( R )</A>. The third 
element is a list of braid relations performing the reverse transformation.

<Example><![CDATA[
gap> R:= RootSystem( "A", 3 );;
gap> LongWords( R )[3];
[ [ 3, 1, 2, 1, 3, 2 ], 
  [ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ], 
      [ 4, 1, 5, 3 ], [ 1, 3, 2, 1 ] ], 
  [ [ 4, 3, 5, 1 ], [ 1, 1, 2, 3 ], [ 2, 2, 3, 3, 4, 2 ], 
      [ 4, 1, 5, 2, 6, 1 ], [ 3, 1, 4, 3 ] ] ]
]]></Example>
</Description>
</ManSection>

</Section>

<Section> <Heading>Quantized enveloping algebras </Heading>

In  <Package>QuaGroup</Package>  we  deal with two types of quantized 
enveloping algebra. First there   are  the  quantized  enveloping  algebras  
defined  over  the  field <Ref Var="QuantumField"/>.  We  say that these 
algebras are <Q>generic</Q> quantized enveloping  algebras,  in  
<Package>QuaGroup</Package>  they  have  the category <A>IsGenericQUEA</A>.
Secondly,  we  deal  with the quantized enveloping algebras that are defined
over a different field.

<ManSection>         
<Attr Name="QuantizedUEA" Arg="R"/>
<Oper Name="QuantizedUEA" Arg="R, F, v" Label="QuantizedUEAOper"/>
<Attr Name="QuantizedUEA" Arg="L" Label="QuantizedUEALieAlg"/>
<Oper Name="QuantizedUEA" Arg="L, F, v" Label="QuantizedUEALieAlgOper"/>
<Description>
In  the  first  two  forms  <A>R</A>  is  a  root system. With only 
<A>R</A> as input, the corresponding  generic  quantized  enveloping  
algebra is constructed. It is stored as an attribute of <A>R</A> (so that 
constructing it twice for the same root system  yields  the  same  object).  
Also  the  root system is stored in the quantized enveloping algebra as the 
attribute <A>RootSystem</A>. <P/>
The  attribute  <A>GeneratorsOfAlgebra</A>  contains  the  generators of a 
PBW-type basis  (see  Section  <Ref Sect="sec2.4"/>),  that  are  constructed  
relative to the reduced expression  for  the  longest element in the Weyl 
group that is contained in <A>LongestWeylWord(  R  )</A>.
We  refer  to  <Ref Oper="ObjByExtRep"/>  for a
description  of  the  construction  of  elements  of  a quantized enveloping
algebra. <P/>
The  call <A>QuantizedUEA( R, F, v )</A> returns the quantized universal 
enveloping algebra  with  quantum  parameter  <A>v</A>, which must lie in the 
field <A>F</A>. In this case the elements of <A>GeneratorsOfAlgebra</A> are 
the images of the generators of the corresponding generic quantized 
enveloping algebra. This means that if <A>v</A> is a root of unity, then the 
generators will not generate the whole algebra, but  rather  a  finite 
dimensional subalgebra (as for instance <M>E_i^k=0</M> for <M>k</M>
large  enough). It is possible to construct elements that do not lie in this
finite dimensional subalgebra using <Ref Oper="ObjByExtRep"/>. <P/>
In  the last two cases <A>L</A> must be a semisimple Lie algebra. The two 
calls are short for <A>QuantizedUEA( RootSystem( L ) )</A> and 
<A>QuantizedUEA( RootSystem( L ), F, v )</A> respectively.
<Example><![CDATA[
gap> # We construct the generic quantized enveloping algebra corresponding
gap> # to the root system of type A2+G2:
gap> R:= RootSystem( [ "A", 2, "G", 2 ] );;
gap> U:= QuantizedUEA( R );
QuantumUEA( <root system of type A2 G2>, Qpar = q )
gap> RootSystem( U );
<root system of type A2 G2>
gap> g:= GeneratorsOfAlgebra( U );
[ F1, F2, F3, F4, F5, F6, F7, F8, F9, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q+q^-1)*[ K2 ; 1 ]+K2, K3, (-q+q^-1)*[ K3 ; 1 ]+K3, K4, 
  (-q^3+q^-3)*[ K4 ; 1 ]+K4, E1, E2, E3, E4, E5, E6, E7, E8, E9 ]
gap> # These elements generate a PBW-type basis of U; the nine elements Fi,
gap> # and the nine elements Ei correspond to the roots listed in convex order:
gap> PositiveRootsInConvexOrder( R );
[ [ 1, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], 
  [ 0, 0, 3, 1 ], [ 0, 0, 2, 1 ], [ 0, 0, 3, 2 ], [ 0, 0, 1, 1 ], 
  [ 0, 0, 0, 1 ] ]
gap> # So, for example, F5 is an element of weight -[ 0, 0, 3, 1 ].
gap> # We can also multiply elements; the result is written on the PBW-basis:
gap> g[17]*g[4];
(-1+q^-6)*F4*[ K4 ; 1 ]+(q^-3)*F4*K4
gap> # Now we construct a non-generic quantized enveloping algebra:
gap> R:= RootSystem( "A", 2 );;
gap> U:= QuantizedUEA( R, CF(3), E(3) );;
gap> g:= GeneratorsOfAlgebra( U );
[ F1, F2, F3, K1, (-E(3)+E(3)^2)*[ K1 ; 1 ]+K1, K2, 
  (-E(3)+E(3)^2)*[ K2 ; 1 ]+K2, E1, E2, E3 ]
]]></Example>
As  can  be  seen  in the example, every element of <M>U</M> is written as a 
linear combination  of  monomials in the PBW-generators; the generators of 
<M>U^-</M> come first, then the generators of <M>U^0</M>, and finally the 
generators of <M>U^+</M>.
</Description>
</ManSection>

<ManSection>         
<Oper Name="ObjByExtRep" Arg="fam, list"/>
<Description>
Here  <A>fam</A>  is  the  elements  family  of  a  quantized enveloping 
algebra <A>U</A>. Secondly,  <A>list</A>  is  a  list describing an element of 
<A>U</A>. We explain how this description  works.  First we describe an 
indexing system for the generators of  <A>U</A>. Let <A>R</A> be the root 
system of <A>U</A>. 
Let <A>t</A> be the number of positive roots, and  <A>rank</A>  the  rank of 
the root system. Then the generators of <A>U</A> are <A>Fk</A>, <A>Ki</A>
(and  its  inverse),  <A>Ek</A>,  for <A>k=1...t</A>, <A>i=1..rank</A>. 
(See Section <Ref Sect="sec2.4"/>; for the construction  of the <A>Fk</A>, 
<A>Ek</A>, the value of  <A>LongestWeylWord( R )</A> is used.) Now the index 
of <A>Fk</A> is <A>k</A>, and the 
index of <A>Ek</A> is <A>t+rank+k</A>. Furthermore, elements
of  the  algebra generated by the <A>Ki</A>, and its inverse, are written as 
linear combinations of products of <Q>binomials</Q>, as in Section  
<Ref Sect="sec2.5"/>. The element
<Display> K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix} </Display>
(where  <M>d=0,1</M>), is indexed as <A>[ t+i, d ]</A> (what happens to the 
<A>s</A> is described later). So an index is either an integer, or a list of 
two integers. <P/>
A  monomial  is  a list of indices, each followed by an exponent. First come
the  indices  of the <A>Fk</A>, (<A>1..t</A>), then come the lists of the form 
<A>[ t+i, d ]</A>, and finally the indices of the <A>Ek</A>. Each index is 
followed by an exponent. An index of the form <A>[ t+i, d ]</A> is followed 
by the <A>s</A> in the above formula. <P/>
The  second  argument  of  <A>ObjByExtRep</A>  is  a  list of monomials 
followed by coefficients. This function returns the element of <A>U</A> 
described by this list.<P/>
Finally we remark that the element
<Display> K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix} </Display>
is printed as <A>Ki[ Ki ; s ]</A> if <A>d=1</A>, and as <A>[ Ki ; s ]</A> 
if <A>d=0</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> fam:= ElementsFamily( FamilyObj( U ) );;
gap> list:= [ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], _q^2,    # monomial and coefficient
> [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ], _q^-1 + _q^2 ]; # monomial and coefficient
[ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], q^2, [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ], 
  q^2+q^-1 ]
gap> ObjByExtRep( fam, list );
(q^2)*F2^(3)*[ K1 ; 8 ]*E1^(11)+(q^2+q^-1)*F1^(7)*F3^(5)*K2[ K2 ; 3 ]*E3^(9)
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="ExtRepOfObj" Arg="elm"/>
<Description>
For the element <A>elm</A> of a quantized enveloping algebra, this function 
returns the list that defines <A>elm</A> (see <Ref Oper="ObjByExtRep"/>).
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> g:= GeneratorsOfAlgebra(U);
[ F1, F2, F3, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, (-q+q^-1)*[ K2 ; 1 ]+K2, E1, 
  E2, E3 ]
gap> ExtRepOfObj( g[5] );
[ [ [ 4, 0 ], 1 ], -q+q^-1, [ [ 4, 1 ], 0 ], 1 ]
]]></Example>
</Description>
</ManSection>


<ManSection>         
<Attr Name="QuantumParameter" Arg="U"/>
<Description>
Returns the quantum parameter used in the definition of <A>U</A>.
<Example><![CDATA[
gap> R:= RootSystem("A",2);;
gap> U0:= QuantizedUEA( R, CF(3), E(3) );;
gap> QuantumParameter( U0 );
E(3)
]]></Example>
</Description>
</ManSection>


<ManSection>         
<Attr Name="CanonicalMapping" Arg="U"/>
<Description>
Here  <A>U</A>  is  a quantized enveloping algebra. Let <A>U0</A> denote
the corresponding <Q>generic</Q> quantized enveloping algebra. This function 
returns the mapping <A>U0 --> U</A>  obtained by mapping <A>q</A> (which is 
the quantum parameter of <A>U0</A>) to the quantum parameter of <A>U</A>.
<Example><![CDATA[
gap> R:= RootSystem("A", 3 );;
gap> U:= QuantizedUEA( R, CF(5), E(5) );;
gap> f:= CanonicalMapping( U );
MappingByFunction( QuantumUEA( <root system of type A
3>, Qpar = q ), QuantumUEA( <root system of type A3>, Qpar = 
E(5) ), function( u ) ... end )
gap> U0:= Source( f );
QuantumUEA( <root system of type A3>, Qpar = q )
gap> g:= GeneratorsOfAlgebra( U0 );;
gap> u:= g[18]*g[9]*g[6];
(q^2)*F6*K2*E6+(q)*K2*[ K3 ; 1 ]
gap> Image( f, u );
(E(5)^2)*F6*K2*E6+(E(5))*K2*[ K3 ; 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="WriteQEAToFile" Arg="U, file"/>
<Description>
Here  <A>U</A> is a quantized enveloping algebra, and file is a string 
containing the  name  of  a  file.  This function writes some data to 
<A>file</A>, that allows <Ref Oper="ReadQEAFromFile"/> to recover it.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",3) );;
gap> WriteQEAToFile( U, "A3" );
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="ReadQEAFromFile" Arg="file"/>
<Description>
Here  <A>file</A>  is  a string containing the name of a file, to which a 
quantized enveloping algebra has been written by <Ref Oper="WriteQEAToFile"/>. 
This function recovers the quantized enveloping algebra.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",3) );;
gap> WriteQEAToFile( U, "A3" );
gap> U0:= ReadQEAFromFile( "A3" );
QuantumUEA( <root system of type A3>, Qpar = q )
]]></Example>
</Description>
</ManSection>

</Section>


<Section> <Heading> Homomorphisms and automorphisms </Heading>

Here we describe functions for creating homomorphisms and
(anti)-automorphisms of a quantized enveloping algebra.

<ManSection>         
<Oper Name="QEAHomomorphism" Arg="U, A, list"/>
<Description>
Here  <A>U</A>  is  a  generic  quantized  enveloping  algebra  (i.e., 
with quantum parameter  <A>&uscore;q</A>),  <A>A</A>  is  an algebra with one 
over <A>QuantumField</A>, and <A>list</A> is a list  of  <A>4*rank</A> 
elements of <A>A</A> (where <A>rank</A> is the rank of the root system of
<A>U</A>).  On  the first rank positions there are the images of the 
<M>F_{\alpha}</M> (where the <M>\alpha</M>  are  simple  roots,  listed  
in the order in which they occur in <A>SimpleSystem(  R  )</A>). On the 
positions <A>rank+1...2*rank</A> are the images of the <M>K_{\alpha}</M>.   
On   the  positions  <A>2*rank+1...3*rank</A>  are  the  images  of  the
<M>K_{\alpha}^{-1}</M>,  and finally on the positions <A>3*rank+1...4*rank</A> 
occur the images of the <M>E_{\alpha}</M>. <P/>
This  function returns the homomorphism <A>U -> A</A>, defined by this data. 
In the example  below  we  construct  a  homomorphism from one quantized 
enveloping algebra into another. Both are constructed relative to the same 
root system, but  with  different reduced expressions for the longest element 
of the Weyl group.
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> SetLongestWeylWord( R, [1,2,1,2,1,2] );
gap> UR:= QuantizedUEA( R );;
gap> S:= RootSystem( "G", 2 );;
gap> SetLongestWeylWord( S, [2,1,2,1,2,1] );
gap> US:= QuantizedUEA( S );;
gap> gS:= GeneratorsOfAlgebra( US );
[ F1, F2, F3, F4, F5, F6, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q^3+q^-3)*[ K2 ; 1 ]+K2, E1, E2, E3, E4, E5, E6 ]
gap> SimpleSystem( R );
[ [ 1, 0 ], [ 0, 1 ] ]
gap> PositiveRootsInConvexOrder( S );
[ [ 0, 1 ], [ 1, 1 ], [ 3, 2 ], [ 2, 1 ], [ 3, 1 ], [ 1, 0 ] ]
gap> # We see that the simple roots of R occur on positions 6 and 1
gap> # in the list PositiveRootsInConvexOrder( S ); This means that we
gap> # get the following list of images of the homomorphism:
gap> imgs:= [ gS[6], gS[1],      # the images of the F_{\alpha}
> gS[7], gS[9],                  # the images of the K_{\alpha}
> gS[8], gS[10],                 # the images of the K_{\alpha}^{-1}
> gS[16], gS[11] ];              # the images of the E_{\alpha}
[ F6, F1, K1, K2, (-q+q^-1)*[ K1 ; 1 ]+K1, (-q^3+q^-3)*[ K2 ; 1 ]+K2, E6, E1 ]
gap> h:= QEAHomomorphism( UR, US, imgs );
<homomorphism: QuantumUEA( <root system of type G
2>, Qpar = q ) -> QuantumUEA( <root system of type G2>, Qpar = q )>
gap> Image( h, GeneratorsOfAlgebra( UR )[3] );
(q^10-q^6-q^4+1)*F1*F6^(2)+(q^6-q^2)*F2*F6+(q^4)*F4
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="QEAAutomorphism" Arg="U, list"/>
<Oper Name="QEAAutomorphism" Arg="U, f" Label="QEAAutomorphismNonGeneric"/>
<Description>
In  the  first  form <A>U</A> is a generic quantized enveloping algebra 
(i.e., with quantum  parameter  <A>&uscore;q</A>),  and  <A>list</A> is a 
list of <A>4*rank</A> elements of <A>U</A> (where <A>rank</A>  is  the  
rank  of  the  corresponding  root system). On the first <A>rank</A>
positions  there  are  the images of the <M>F_{\alpha}</M> (where the 
<M>\alpha</M> are simple roots, listed in the order in which they occur in 
<A>SimpleSystem( R )</A>). On the positions  <A>rank+1...2*rank</A>  are  
the images of the <M>K_{\alpha}</M>. On the positions
<A>2*rank+1...3*rank</A>  are  the  images  of  the  <M>K_{\alpha}^{-1}</M>, 
and finally on the positions <A>3*rank+1...4*rank</A> occur the images of 
the <M>E_{\alpha}</M>.<P/>
In the second form <A>U</A> is a non-generic quantized enveloping algebra, 
and <A>f</A> is an  automorphism  of the corresponding generic quantized 
enveloping algebra. The  corresponding automorphism of <A>U</A> is 
constructed. In this case <A>f</A> must not be  the  bar-automorphism  of the 
corresponding generic quantized enveloping algebra  (cf. 
<Ref Attr="BarAutomorphism"/>), as this automorphism doesn't work in the 
non-generic case.<P/>
The image of an element <A>x</A> under an automorphism <A>f</A> is computed 
by <A>Image( f, x )</A>.  Note  that  there  is no function for calculating 
pre-images (in general this  seems  to  be  a  very  hard  task).  If  you  
want  the inverse of an automorphism, you have to construct it explicitly 
(e.g., by <A>QEAAutomorphism( U, list )</A>, where <A>list</A> is a list of 
pre-images). <P/>
Below we construct the automorphism <M>\omega</M> (cf. Section 
<Ref Sect="sec2.2"/>) of the quantized
enveloping  of  type  <M>A_3</M>,  when  the  quantum parameter is 
<A>&uscore;q</A>, and when the quantum parameter is a fifth root of unity.
<Example><![CDATA[
gap> # First we construct the quantized enveloping algebra:
gap> R:= RootSystem( "A", 3 );;
gap> U0:= QuantizedUEA( R );
QuantumUEA( <root system of type A3>, Qpar = q )
gap> g:= GeneratorsOfAlgebra( U0 );
[ F1, F2, F3, F4, F5, F6, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q+q^-1)*[ K2 ; 1 ]+K2, K3, (-q+q^-1)*[ K3 ; 1 ]+K3, E1, E2, E3, E4, E5, 
  E6 ]
gap> # Now, for instance, we map F_{\alpha} to E_{\alpha}, where \alpha
gap> # is a simple root. In order to find where those F_{\alpha}, E_{\alpha}
gap> # are in the list of generators, we look at the list of positive roots
gap> # in convex order:
gap> PositiveRootsInConvexOrder( R );
[ [ 1, 0, 0 ], [ 1, 1, 0 ], [ 0, 1, 0 ], [ 1, 1, 1 ], [ 0, 1, 1 ], 
  [ 0, 0, 1 ] ]
gap> # So the simple roots occur on positions 1, 3, 6. This means that we
gap> # have the following list of images:
gap> imgs:= [ g[13], g[15], g[18], g[8], g[10], g[12], g[7], g[9], g[11], 
> g[1], g[3], g[6] ];
[ E1, E3, E6, (-q+q^-1)*[ K1 ; 1 ]+K1, (-q+q^-1)*[ K2 ; 1 ]+K2, 
  (-q+q^-1)*[ K3 ; 1 ]+K3, K1, K2, K3, F1, F3, F6 ]
gap> f:= QEAAutomorphism( U0, imgs );
<automorphism of QuantumUEA( <root system of type A3>, Qpar = q )>
gap> Image( f, g[2] );
(-q)*E2
gap> # f induces an automorphism of any non-generic quantized enveloping
gap> # algebra with the same root system R:
gap> U1:= QuantizedUEA( R, CF(5), E(5) );
QuantumUEA( <root system of type A3>, Qpar = E(5) )
gap> h:= QEAAutomorphism( U1, f );
<automorphism of QuantumUEA( <root system of type A3>, Qpar = E(5) )>
gap> Image( h, GeneratorsOfAlgebra(U1)[7] );
(-E(5)+E(5)^4)*[ K1 ; 1 ]+K1
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="QEAAntiAutomorphism" Arg="U, list"/>
<Oper Name="QEAAntiAutomorphism" Arg="U, f" Label="QEAAntiAutomorphismNonGeneric"/>
<Description>
These   are  functions  for  constructing  anti-automorphisms  of  quantized
enveloping algebras. The same comments apply as for 
<Ref Oper="QEAAutomorphism"/>.
</Description>
</ManSection>

<ManSection>         
<Attr Name="AutomorphismOmega" Arg="U"/>
<Description>
This is the automorphism <M>\omega</M> (cf. Section <Ref Sect="sec2.2"/>).
<Example><![CDATA[
gap> R:= RootSystem( "A", 3 );;
gap> U:= QuantizedUEA( R, CF(5), E(5) );
QuantumUEA( <root system of type A3>, Qpar = E(5) )
gap> f:= AutomorphismOmega( U );
<automorphism of QuantumUEA( <root system of type A3>, Qpar = E(5) )>
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="AntiAutomorphismTau" Arg=""/>
<Description>
This is the anti-automorphism <M>\tau</M> (cf. Section <Ref Sect="sec2.2"/>).
<Example><![CDATA[
gap> R:= RootSystem( "A", 3 );;
gap> U:= QuantizedUEA( R, CF(5), E(5) );
QuantumUEA( <root system of type A3>, Qpar = E(5) )
gap> t:= AntiAutomorphismTau( U );
<anti-automorphism of QuantumUEA( <root system of type A3>, Qpar = E(5) )>
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Attr Name="BarAutomorphism" Arg="U"/>
<Description>
This  is  the  automorphism <M>\bar{~}</M> defined in Section 
<Ref Sect="sec2.2"/>  Here <A>U</A> must be a generic quantized enveloping 
algebra.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem(["A",2,"B",2]) );;
gap> bar:= BarAutomorphism( U );
<automorphism of QuantumUEA( <root system of type A2 B2>, Qpar = q )>
gap> Image( bar, GeneratorsOfAlgebra( U )[5] );
(q^2-q^-2)*F4*F7+F5
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="AutomorphismTalpha" Arg="U, ind"/>
<Description>
This  is  the  automorphism  <M>T_{\alpha}</M>  (cf.  Section 
<Ref Sect="sec2.4"/>), where <M>\alpha</M> is the <A>ind</A>-th simple root.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "B", 3 ) );;
gap> f:=AutomorphismTalpha( U, 1 );
<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>
gap> a:= GeneratorsOfAlgebra( U )[3];
F3
gap>  Image( f, a );
F2
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="DiagramAutomorphism" Arg="U, perm"/>
<Description>
This  is  the  automorphism  of  <A>U</A>  induced by a diagram automorphism 
of the underlying  root  system.  The  diagram  automorphism  is represented 
by the permutation <A>perm</A>, which is the permutation of the simple roots 
performed by the diagram automorphism.<P/>
In  the  example  below  we  construct  the diagram automorphism of the root
system of type <M>A_3</M>, which is represented by the permutation 
<A>(1,3)</A>.
<Example><![CDATA[
gap> R:= RootSystem( "A", 3 );;
gap> U:= QuantizedUEA( R );;
gap> f:= DiagramAutomorphism( U, (1,3) );
<automorphism of QuantumUEA( <root system of type A3>, Qpar = q )>
gap> g:= GeneratorsOfAlgebra( U );
[ F1, F2, F3, F4, F5, F6, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q+q^-1)*[ K2 ; 1 ]+K2, K3, (-q+q^-1)*[ K3 ; 1 ]+K3, E1, E2, E3, E4, E5, 
  E6 ]
gap> Image( f, g[1] );
F6
]]></Example>
</Description>
</ManSection>

<ManSection>         
<Oper Name="\*" Arg="f, h"/>
<Description>
We  can  compose  automorphisms  and  anti-automorphisms  using  the infix 
<A>*</A> operator.  The result of composing two automorphisms is an 
automorphism. The result   of  composing  an  automorphism  and  an  
anti-automorphism  is  an anti-automorphism.  The  result  of  composing  
two anti-automorphisms is an automorphism.

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "B", 3 ) );;
gap> f:=AutomorphismTalpha( U, 1 );
<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>
gap> h:= AutomorphismOmega( U );
<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>
gap> f*h;
<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>
gap> t:= AntiAutomorphismTau( U );;
gap> T:= AutomorphismTalpha( U, 2 );;
gap> Tinv:= t*T*t;
<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>
gap> # (The last call may take a little while.)
gap> x:= Image( T, GeneratorsOfAlgebra( U )[1] );
(-q^4+1)*F1*F3+(-q^2)*F2
gap> Image( Tinv, x );
F1
]]></Example>
According  to <Cite Key="J96"/>,  8.14(10),  
<M>\tau \circ  T_{\alpha} \circ \tau</M> is the inverse of <M>T_{\alpha}</M>.
</Description>
</ManSection>

</Section>

<Section> <Heading>Hopf algebra structure</Heading>

Here  we describe functions for dealing with the Hopf algebra structure of a
quantized  enveloping algebra. This structure enables us to construct tensor
products,  and  dual modules of modules over a quantized enveloping algebra.
We  refer  to the next section (Section <Ref Sect="sec3.8"/>) for some 
functions for creating modules.

<ManSection>         
<Oper Name="TensorPower" Arg="U, d"/>
<Description>
Here <A>U</A> is a quantized universal enveloping algebra, and <A>d</A> a 
non-negative integer. This function returns the associative algebra with 
underlying vector space the <A>d</A>-fold tensor product of <A>U</A> with 
itself. The product is defined component wise.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( [ "B", 2 ] ) );;
gap> T:= TensorPower( U, 3 );
<algebra over QuantumField, with 36 generators>
gap> g:= GeneratorsOfAlgebra( T );;
gap> x:= g[1];
1*(1<x>1<x>F1)
gap> y:= g[30];
1*(E2<x>1<x>1)
gap> x*y;
1*(E2<x>1<x>F1)
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="UseTwistedHopfStructure" Arg="U, f, finv"/>
<Description>
Here <A>U</A> is a quantized enveloping algebra, and <A>f</A>, <A>finv</A> 
two (anti-) automorphisms of <A>U</A>, where <A>finv</A> is the inverse of 
<A>f</A>. After calling this function the Hopf structure on <A>U</A> is used 
that is obtained from the <Q>normal</Q> Hopf structure (see Section 
<Ref Sect="sec2.3"/>) by twisting it with <A>f</A>. <P/>
A call to this function sets the attribute <A>HopfStructureTwist</A>, which 
is the list <A>[ f, finv ]</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap> t:= AntiAutomorphismTau( U );;
gap> UseTwistedHopfStructure( U, t, t );
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="ComultiplicationMap" Arg="U, d"/>
<Description>
This is a homomorphism from the quantized enveloping algebra <A>U</A> to the 
<A>d</A>-fold tensor power of <A>U</A> with itself. It is obtained by a 
repeated application of the comultiplication of <A>U</A>. So for 
<A>d=2</A> we get the comultiplication of <A>U</A>.

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap> D:= ComultiplicationMap( U, 3 );
<Comultiplication of QuantumUEA( <root system of type A2>, Qpar = 
E(5) ), degree 3>
gap> Image( D, GeneratorsOfAlgebra(U)[4] );
1*(K1<x>K1<x>K1)
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="AntipodeMap" Arg="U"/>
<Description>
This is the antipode map of the quantized enveloping algebra <A>U</A>, which is
constructed as an anti-automorphism of <A>U</A>.

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap> a:= AntipodeMap( U );
<anti-automorphism of QuantumUEA( <root system of type A2>, Qpar = E(5) )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="CounitMap" Arg="U"/>
<Description>
This is the counit map of the quantized enveloping algebra <A>U</A>, which is
constructed as a function from <A>U</A> to the ground field.

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap> co:= CounitMap( U );
function( u ) ... end
gap> x:= GeneratorsOfAlgebra( U )[4];
K1
gap> co( x );
1
]]></Example>
</Description>
</ManSection>

</Section>

<Section Label="sec3.8"> <Heading>Modules</Heading>

Here we describe some functions for constructing left modules over quantized
enveloping algebras. We refer to the &GAP; reference manual for an overview of
basic functions for algebra modules, which are also applicable to the
modules constructed by the functions described in this section. We mention
<A>MatrixOfAction</A>, <A>DirectSumOfAlgebraModules</A>. The action of an 
element of the algebra on an element of the module is calculated by the 
infix operator <A>&circum;</A>.

<ManSection>     
<Oper Name="HighestWeightModule" Label="for a quantized env. alg." Arg="U, wt"/>
<Description>
Here <A>U</A> is a quantized universal enveloping algebra, and <A>wt</A> 
a dominant weight (i.e.,  a list of length equal to the rank of the root 
system, consisting of non-negative   integers).   This   function   returns  
a  finite-dimensional highest-weight module of highest weight <A>wt</A> over
<A>U</A>. If <A>U</A> is generic then this is the unique irreducible 
highest-weight module over <A>U</A>. Otherwise it is the Weyl  module,  cf.  
Section  <Ref Sect="sec2.5"/>.  In  this  last  case  the  module  is not
necessarily irreducible.<P/>
Let  <A>V</A>  denote the module returned by this function. The first basis 
element of  the  attribute  <A>Basis( V )</A> is a highest-weight vector; 
it is written as <A>1*v0</A>.  Other  basis  elements  are  written as, 
for example, <A>F2*F9*v0</A>, which means  that  this vector is the result 
of letting the PBW-monomial <A>F2*F9</A> act on the highest-weight vector.<P/>

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( [ "A", 2, "G", 2 ] ) );;
gap> V:= HighestWeightModule( U, [ 0, 1, 0, 2 ] );
<231-dimensional left-module over QuantumUEA( <root system of type A2 G
2>, Qpar = q )>
gap> Basis( V )[1];
1*v0
gap> Basis(V)[23]+(_q^2+_q^-2)*Basis(V)[137];
F3*F5*v0+(q^2+q^-2)*F8^(6)*v0
gap> # We compute the action of an element on a vector:
gap> gg:= GeneratorsOfAlgebra( U );;
gap> x:= gg[21]*gg[5];
F5*E4+(-q^-1)*F6*K3
gap> x^Basis(V)[1];
(-q^-1)*F6*v0
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="IrreducibleQuotient" Arg="V"/>
<Description>
Here  <A>V</A>  is  a highest-weight module over a non-generic quantized 
enveloping algebra.  This  function  returns the quotient of <A>V</A> by 
the maximal submodule not containing the highest weight vector. This is 
not necessarily equal to <A>V</A> if the quantum parameter is a root of 1.
<Example><![CDATA[
gap> R:= RootSystem( "A", 2 );;
gap> U:= QuantizedUEA( R, CF(3), E(3) );;
gap> V:= HighestWeightModule( U, [1,1] );
<8-dimensional left-module over QuantumUEA( <root system of type A2>, Qpar = 
E(3) )>
gap> IrreducibleQuotient( V );
<7-dimensional left-module over QuantumUEA( <root system of type A2>, Qpar = 
E(3) )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="HWModuleByTensorProduct" Arg="U, wt"/>
<Description>
Here <A>U</A> must be a <E>generic</E> quantized enveloping algebra, and
<A>wt</A> a dominant weight. This function returns the irreducible 
highest-weight module with highest weight <A>wt</A>. The algorithm uses
tensor products (whence the name). On some inputs this algorithm is
faster than the one use for 
<Ref Oper="HighestWeightModule" Label="for a quantized env. alg."/>, on some inputs
it is slower. I do not know any good heuristics. <P/>
The basis supplied with the module returned is the canonical basis.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("G",2) );;
gap> V:= HWModuleByTensorProduct( U, [2,1] );
<189-dimensional left-module over QuantumUEA( <root system of type G
2>, Qpar = q )>
gap> # (This is a case where this algorithm is a lot faster.)
]]></Example>
</Description>
</ManSection>


<ManSection>     
<Oper Name="DIYModule" Arg="U, V, acts"/>
<Description>
Here <A>U</A>  is  a generic quantized enveloping algebra, and <A>V</A> is 
a vector space over  the  field <A>QuantumField</A>. <A>U</A> acts on <A>V</A> 
and the action is described by the data  in  the  list <A>acts</A>. 
<A>acts</A> is a list of lists, of length <A>4*l</A>, where <A>l</A> is
the  rank  of  the  root system. <A>acts</A> describes the actions of the 
generators <M>[F_1,...,F_l,K_1,...,K_l,K_1^-1,...,K_l^-1,  E_1,...,E_l ]</M>. 
(Here <M>F_k</M> is the generator <M>F_{\alpha_k}</M>, where <M>\alpha_k</M> 
is the <M>k</M>-th simple root, and likewise for <M>E_k</M>.)  The  action 
of each generator is described by a list of length <A>dim V</A>,
giving  the  images  of the basis elements of <A>V</A>. If an image is zero 
then it may  be  omitted:  in that case there is a <Q>hole</Q> in the list. 
This function returns the <A>U</A>-module defined by the input.<P/>
Let  <A>R</A>  be  a  root  system  of  type <M>A_1</M>, and <A>U</A> the 
corresponding quantized enveloping  algebra  (generated  by  
<M>F, K, K^-1, E</M>). In the example below we construct  the  2-dimensional  
<M>U</M>-module  with  basis  vectors  <M>v_1,v_2</M>,  and
<A>U</A>-action  given  by  <M>Fv_1  = v_2</M>, <M>Fv_2=0</M>, 
<M>Kv_1 = qv_1</M>, <M>Kv_2=q^{-1}v_2</M>, <M>Ev_1=0</M>,
<M>Ev_2=v_1</M>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",1) );
QuantumUEA( <root system of type A1>, Qpar = q )
gap> V:= QuantumField^2;
( QuantumField^2 )
gap> v:= BasisVectors( Basis(V) );
[ [ 1, 0 ], [ 0, 1 ] ]
gap> acts:= [ [ v[2], 0*v[1] ], [ _q*v[1], _q^-1*v[2] ], 
> [ _q^-1*v[1], _q*v[2] ], [ 0*v[1], v[1] ] ];;
gap> M:= DIYModule( U, V, acts );
<2-dimensional left-module over QuantumUEA( <root system of type A
1>, Qpar = q )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="TensorProductOfAlgebraModules" Arg="V, W"/>
<Oper Name="TensorProductOfAlgebraModules" Arg="list" Label="TensorProductOfAlgebraModules"/>
<Description>
Here  <A>V</A> and <A>W</A> are two modules over the same quantized 
enveloping algebra <A>U</A>. This  function constructs the tensor product 
of <A>V</A> and <A>W</A> (as a <A>U</A>-module). For
this  the  comultiplication  map  of  <A>U</A>  is  used  (see  
<Ref Attr="ComultiplicationMap"/>). <P/>
In  the  second  form <A>list</A> is a list of <A>U</A>-modules. In that case 
the iterated tensor product is constructed.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;
gap> V1:= HighestWeightModule( U, [ 1, 0 ] );;
gap> V2:= HighestWeightModule( U, [ 0, 1 ] );;
gap> TensorProductOfAlgebraModules( V1, V2 );
<9-dimensional left-module over QuantumUEA( <root system of type A
2>, Qpar = q )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="HWModuleByGenerator" Arg="V, v, hw"/>
<Description>
Here  <A>V</A>  is  a  module over a generic quantized enveloping algebra 
<A>U</A>, <A>v</A> is a highest-weight  vector  (i.e.,  all  
<M>E_{\alpha}</M><A>v=0</A>),  of  weight  <A>hw</A>, which must be
dominant. This function returns a highest-weight module over <A>U</A> 
isomorphic to the submodule of <A>V</A> generated by <A>v</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("B",2) );;
gap> W1:= HighestWeightModule( U, [1,0] );;
gap> W2:= HighestWeightModule( U, [0,1] );;
gap> T:= TensorProductOfAlgebraModules( W1, W2 );
<20-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>
gap> HWModuleByGenerator( T, Basis(T)[1], [1,1] );
<16-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="InducedQEAModule" Arg="U, V"/>
<Description>
Here <A>U</A>  is  a non-generic quantized enveloping algebra, and 
<A>V</A> a module over the  corresponding  generic  quantized  enveloping  
algebra.  This  function returns  the  <A>U</A>-module  obtained  from  
<A>V</A> by setting <A>&uscore;q</A> equal to the quantum
parameter of <A>U</A>.
<Example><![CDATA[
gap> R:= RootSystem("B",2);;
gap> U:= QuantizedUEA( R );;
gap> U0:= QuantizedUEA( R, CF(3), E(3) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> W:= InducedQEAModule( U0, V );
<16-dimensional left-module over QuantumUEA( <root system of type B2>, Qpar = 
E(3) )>
gap> # This module is isomorphic to the one obtained by
gap> # HighestWeightModule( U0, [1,1] );
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="GenericModule" Arg="W"/>
<Description>
For  an  induced module (see <Ref Oper="InducedQEAModule"/>) this function 
returns the corresponding module over the generic quantized enveloping algebra.
</Description>
</ManSection>

<ManSection>     
<Attr Name="CanonicalMapping" Arg="W" Label="CanonicalMappingInducedModule"/>
<Description>
Here  <A>W</A> is an induced module. Let <A>V</A> be the corresponding 
generic module (<Ref Attr="GenericModule"/>). This function returns the map 
<A>V --> W</A>, that sets <A>&uscore;q</A> equal to the quantum parameter 
of the acting algebra of <A>W</A>.
<Example><![CDATA[
gap> R:= RootSystem("B",2);;
gap> U:= QuantizedUEA( R );;
gap> U0:= QuantizedUEA( R, CF(3), E(3) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> W:= InducedQEAModule( U0, V );;
gap> f:= CanonicalMapping( W );
MappingByFunction( <
16-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>, <
16-dimensional left-module over QuantumUEA( <root system of type B2>, Qpar = 
E(3) )>, function( v ) ... end )
gap> Image( f, _q^2*Basis(V)[3] );
(E(3)^2)*e.3
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="U2Module" Arg="U, hw"/>
<Description>
Here  <A>U</A>  must  be  a quantized enveloping algebra of type <M>A_2</M>. 
This function returns the highest-weight module over <A>U</A> of 
highest-weight <A>hw</A> (which must be dominant). This function is generally
a lot faster than
<Ref Oper="HighestWeightModule" Label="for a quantized env. alg."/>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> A2Module( U, [4,7] );
<260-dimensional left-module over QuantumUEA( <root system of type A
2>, Qpar = q )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="MinusculeModule" Arg="U, hw"/>
<Description>
Here <A>U</A>  must  be a generic quantized enveloping algebra, and 
<A>hw</A> a minuscule dominant  weight.  This function returns the 
highest-weight module over <A>U</A> of highest-weight <A>hw</A>. This  
function  is  generally  somewhat  faster  than
<Ref Oper="HighestWeightModule" Label="for a quantized env. alg."/>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",5) );;
gap> MinusculeModule( U, [0,0,1,0,0] );
<20-dimensional left-module over QuantumUEA( <root system of type A
5>, Qpar = q )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="DualAlgebraModule" Arg="V"/>
<Description>
Here <A>V</A>  is  a  finite-dimensional  left  module over a quantized 
enveloping algebra <A>U</A>.  This function returns the dual space of 
<A>V</A> as an algebra module. For this the antipode map of <A>U</A> is 
used (see <Ref Attr="AntipodeMap"/>). <P/>
Let  <A>M</A> denote the module returned by this function. Then <A>M</A> 
has as basis the dual  basis  with respect to <A>Basis( V )</A>. An element 
of this basis is printed as  <A>F@v</A>,  where  <A>v</A>  is  an element of 
<A>Basis( V )</A>. This is the function which takes  the value <A>1</A> on 
<A>v</A> and <A>0</A> on all other basis elements. A general element
of <A>M</A> is a linear combination of these basis elements. <P/>
The  elements of <A>M</A> can be viewed as functions which take arguments. 
However, internally  the  elements  of <A>M</A> are represented as wrapped 
up functions. The function  corresponding to an element <A>m</A> of <A>M</A> 
is obtained by <A>ExtRepOfObj( m )</A> (the  result  of  which is printed in 
the same way as <A>m</A>, but is not equal to it).
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> M:= DualAlgebraModule( V );
<8-dimensional left-module over QuantumUEA( <root system of type A
2>, Qpar = q )>
gap> u:= GeneratorsOfAlgebra( U )[2];
F2
gap> vv:= BasisVectors( Basis( M ) );
[ (1)*F@1*v0, (1)*F@F1*v0, (1)*F@F3*v0, (1)*F@F1*F3*v0, (1)*F@F2*v0, 
  (1)*F@F1*F2*v0, (1)*F@F2*F3*v0, (1)*F@F2^(2)*v0 ]
gap> u^vv[3];
<zero function>
gap> # (The zero of the dual space is printed as <zero function>).
gap> u^vv[4];
(-q^5+q^3)*F@1*v0
gap> # We get the function corresponding to a vector in M by using ExtRepOfObj:
gap> f:= ExtRepOfObj( vv[1] );
(1)*F@1*v0
gap> # We can calculate images of this function:
gap> List( Basis(V), v -> Image( f, v ) );
[ 1, 0, 0, 0, 0, 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="TrivialAlgebraModule" Arg="U"/>
<Description>
Returns the trivial module over the quantized enveloping algebra <A>U</A>. 
For this the counit map of <A>U</A> is used.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> V:= TrivialAlgebraModule( U );
<left-module over QuantumUEA( <root system of type A2>, Qpar = q )>
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="WeightsAndVectors" Arg="V"/>
<Description>
Here <A>V</A> is a left module over a quantized enveloping algebra. 
<A>WeightsAndVectors( V )</A> is a list  of two lists; the first of these is a 
list of the weights of <A>V</A>, the second  a  list  of corresponding weight 
vectors. These are again grouped in lists:  if  the  multiplicity  of  a  
weight  is  <A>m</A>, then there are <A>m</A> weight vectors, forming a basis 
of the corresponding weight space. <P/>
Modules   constructed  by  
<Ref Oper="HighestWeightModule" Label="for a quantized env. alg."/> come  with  this
attribute  set. There is a method installed for computing 
<A>WeightsAndVectors( V )</A>,  for  modules <A>V</A> over a generic quantized 
enveloping algebra, such that all basis vectors (i.e., all elements of 
<A>Basis( V )</A>) are weight vectors.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "A", 2 ) );;
gap> V:= HighestWeightModule( U, [ 1, 1 ] );;
gap> WeightsAndVectors( V );
[ [ [ 1, 1 ], [ -1, 2 ], [ 2, -1 ], [ 0, 0 ], [ -2, 1 ], [ 1, -2 ], 
      [ -1, -1 ] ], 
  [ [ 1*v0 ], [ F1*v0 ], [ F3*v0 ], [ F1*F3*v0, F2*v0 ], [ F1*F2*v0 ], 
      [ F2*F3*v0 ], [ F2^(2)*v0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="HighestWeightsAndVectors" Arg="V"/>
<Description>
Is analogous to <Ref Attr="WeightsAndVectors"/>; now only the highest weights 
are listed along with the corresponding highest-weight vectors. <P/>
There  is  a  method  installed  for this using 
<Ref Attr="WeightsAndVectors"/>;
which means that it works if and only if <A>WeightsAndVectors( V )</A> works.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;
gap> V:= HighestWeightModule( U, [ 1, 1 ] );;
gap> HighestWeightsAndVectors( V );
[ [ [ 1, 1 ] ], [ [ 1*v0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Attr Name="RMatrix" Arg="V"/>
<Description>
Here <A>V</A> is a module over the a quantized enveloping algebra <A>U</A>. 
This function returns  the  matrix of a linear map <M>\theta : V\otimes V
\to V\otimes V</M> that is a solution to the quantum Yang-Baxter equation. 
We have that <M>\theta\circ P</M> is an isomorphism  of  <A>U</A>-modules, 
where <M>P :V\otimes V\to V\otimes V</M> is the linear map
such  that <M>P(v\otimes  w)=w\otimes  v</M>.  For  more  details we refer 
to <Cite Key="J96"/>, Chapter 7. <P/>
This function works for modules for which <Ref Attr="WeightsAndVectors"/> 
works. 

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",1) );;
gap> V:= HighestWeightModule( U, [1] );;
gap> RMatrix( V );
[ [ 1, 0, 0, 0 ], [ 0, q, -q^2+1, 0 ], [ 0, 0, q, 0 ], [ 0, 0, 0, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="IsomorphismOfTensorModules" Arg="V, W"/>
<Description>
Here <A>V</A>, <A>W</A> are two modules over the same quantized enveloping 
algebra <A>U</A>. This function  returns  a  linear  map  
<M>\theta  : V\otimes W\to W\otimes V</M> that is an isomorphism of U-modules.
<P/>
This  function  is  only  guaranteed  to  work correctly if the Hopf algebra
structure is non-twisted (see <Ref Oper="UseTwistedHopfStructure"/>). <P/>
This function works for modules for which <Ref Attr="WeightsAndVectors"/> 
works. 

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("B",2) );;
gap> V:= HighestWeightModule( U, [1,0] );;
gap> W:= HighestWeightModule( U, [0,1] );;
gap> h:= IsomorphismOfTensorModules( V, W );;
gap> VW:= Source( h );
<20-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>
gap> Image( h, Basis(VW)[13] );
q*(1*v0<x>F3*v0)+-q^2+1*(F4*v0<x>F2*v0)+-q^3+q^-1*(F3*v0<x>1*v0)
]]></Example>
</Description>
</ManSection>

<ManSection>     
<Oper Name="WriteModuleToFile" Arg="V, file"/>
<Description>
Here <A>V</A> is a module over a quantized enveloping algebra, and <A>file</A> 
is a string containing the name of a file. This function writes some data to 
<A>file</A>, that allows <Ref Oper="ReadModuleFromFile"/> to recover it.<P/>
We  remark  that  this  function  currently  is only implemented for generic
quantized enveloping algebras.
</Description>
</ManSection>

<ManSection>     
<Oper Name="ReadModuleFromFile" Arg="file"/>
<Description>
Here <A>file</A> is a string containing the name of a file, to which a module 
over a  quantized  enveloping  algebra  has  been  written  by  
<Ref Oper="WriteModuleToFile"/>. This function recovers the module. More 
precisely: a new module is constructed  that  is  isomorphic to the old one. 
In the process the algebra acting  on  the  module is constructed anew (from 
data written to the file). This algebra can be accessed by 
<A>LeftActingAlgebra( V )</A>. <P/>
We  remark  that  this  function  currently  is only implemented for generic
quantized enveloping algebras.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",3) );;
gap> V:= HighestWeightModule( U, [1,1,1] );;
gap> WriteModuleToFile( V, "A3mod" );
gap> W:= ReadModuleFromFile( "A3mod" );
<64-dimensional left-module over QuantumUEA( <root system of type A
3>, Qpar = q )>
]]></Example>
</Description>
</ManSection>


</Section>

<Section> <Heading>The path model</Heading>
In  this  section  we describe functions for dealing with the path model. We
work only with LS-paths, which are represented by two lists, one of weights,
and one of rationals (see Section <Ref Sect="sec2.7"/>).

<ManSection>     
<Oper Name="DominantLSPath" Arg="R, wt"/>
<Description>
Here <A>R</A> is a root system, and <A>wt</A> a dominant weight in the 
weight lattice of <A>R</A>. This function returns the LS-path that is the 
line from the origin to <A>wt</A>.
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> DominantLSPath( R, [1,3] );
<LS path of shape [ 1, 3 ] ending in [ 1, 3 ] >
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Falpha" Label="for an LS-path" Arg="path, ind"/>
<Description>
Is the result of applying the path operator <M>f_{\alpha_{<A>ind</A>}}</M>
to the LS-path <A>path</A> (where <M>\alpha_{<A>ind</A>}</M> is the 
<A>ind</A>-th simple root). <P/>
The result is <A>fail</A> if <M>f_{\alpha_{<A>ind</A>}}</M><A>(path)=0</A>.
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> p:=DominantLSPath( R, [1,3] );;
gap> p1:=Falpha( p, 1 );
<LS path of shape [ 1, 3 ] ending in [ -1, 4 ] >
gap> Falpha( p1, 1 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Ealpha" Label="for an LS-path" Arg="path, ind"/>
<Description>
Is the result of applying the path operator <M>e_{\alpha_{<A>ind</A>}}</M>
to the LS-path <A>path</A> (where <M>\alpha_{<A>ind</A>}</M> is the 
<A>ind</A>-th simple root). <P/>
The result is <A>fail</A> if <M>e_{\alpha_{<A>ind</A>}}</M><A>(path)=0</A>.
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> p:=DominantLSPath( R, [1,3] );;
gap> Ealpha( p, 2 );
fail
gap> p1:=Falpha( p, 1 );;
gap> Ealpha( p1, 1 );
<LS path of shape [ 1, 3 ] ending in [ 1, 3 ] >
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="LSSequence" Arg="path"/>
<Description>
returns the two sequences (of weights and rational numbers) that define the
LS-path path.
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> p:=DominantLSPath( R, [1,3] );;
gap> p1:= Falpha( Falpha( p, 1 ), 2 );;
gap> LSSequence( p1 );
[ [ [ 11, -4 ], [ -1, 4 ] ], [ 0, 1/4, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="WeylWord" Arg="path"/>
<Description>
Here <A>path</A> is an LS-path in the orbit (under the root operators) of a
dominant LS-path ending in the dominant weight <M>\lambda</M>. This means 
that the first direction of path is of the form <M>w(\lambda)</M> for some
<M>w</M> in the Weyl group. This function returns a list 
<M>[i_1,\ldots, i_m ]</M> such that <M>w=s_{i_1}\cdots s_{i_m}</M>.
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> p:=DominantLSPath( R, [1,3] );;
gap> p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;
gap> WeylWord( p1 );
[ 1, 2, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>   
<Attr Name="EndWeight" Arg="path"/>
<Description>
Here <A>path</A> is an LS-path; this function returns the weight that is the
endpoint of path
<Example><![CDATA[
gap> R:= RootSystem( "G", 2 );;
gap> p:=DominantLSPath( R, [1,3] );;
gap> p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;
gap> EndWeight( p1 );
[ 0, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>   
<Func Name="CrystalGraph" Label="for root system and weight" Arg="R, wt"/>
<Description>
This function returns a record describing the crystal graph of the
highest-weight module with highest weight <A>wt</A>, over the quantized 
enveloping algebra corresponding to <A>R</A>. It is computed using the 
path model. Therefore the points in the graph are LS-paths. <P/>
Denote the output by <A>r</A>; then <A>r.points</A> is the list of points of 
the graph. Furthermore, <A>r.edges</A> is a list of edges of the graph; this 
is a list of elements of the form <A>[ [ i, j ], u ]</A>. This means that 
there is an arrow from point <A>i</A> (i.e., the point on position <A>i</A> 
in <A>r.points</A>) to point <A>j</A>, with label <A>u</A>.

<Example><![CDATA[
gap> R:= RootSystem( "A", 2 );;
gap> CrystalGraph( R, [1,1] );
rec( 
  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ], 
      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ], 
      [ [ 7, 8 ], 2 ] ], 
  points := [ <LS path of shape [ 1, 1 ] ending in [ 1, 1 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ -1, 2 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ 2, -1 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ 0, 0 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ 0, 0 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ 1, -2 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ -2, 1 ] >, 
      <LS path of shape [ 1, 1 ] ending in [ -1, -1 ] > ] )
]]></Example>
</Description>
</ManSection>

</Section>

<Section> <Heading> Canonical bases </Heading>
Here we describe functions for computing the canonical basis of the negative
part of a quantized enveloping algebra, and of a module.

<ManSection> 
<Oper Name="Falpha" Label="for a PBW-monomial" Arg="x, ind"/>
<Description>
Here  <A>x</A>  is  a  PBW-monomial in <M>U^-</M> (i.e., a monomial in the 
<M>F_{\alpha}</M>, where <M>\alpha</M>  runs  over  the  positive  roots). 
This function returns the result of applying  the  <A>ind</A>-th  Kashiwara  
operator  <M>\widetilde{F}_{\alpha_{<A>ind</A>}}</M> to <M>x</M> (cf.
Section <Ref Sect="sec2.6"/>).
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap> x:= One( U );
1
gap> Falpha( Falpha( x, 3 ), 2 );
F3*F9
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Ealpha" Label="for a PBW-monomial" Arg="x, ind"/>
<Description>
Here  <A>x</A>  is  a  PBW-monomial in <M>U^-</M> (i.e., a monomial in the 
<M>F_{\alpha}</M>, where <M>\alpha</M>  runs  over  the  positive  roots). 
This function returns the result of applying  the  <A>ind</A>-th  Kashiwara  
operator  <M>\widetilde{E}_{\alpha_{<A>ind</A>}}</M> to <M>x</M> (cf.
Section <Ref Sect="sec2.6"/>).
The result is <A>fail</A> if 
<M>\widetilde{E}_{\alpha_{<A>ind</A>}}</M><A>(x)=0</A>.

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap> Ealpha( One( U ), 2 );
fail
gap> g:= GeneratorsOfAlgebra( U );;
gap> x:= g[1]*g[4]*g[7]*g[17];
F1*F4*F7*F17
gap> Ealpha( x, 3 );
F1*F2*F7*F17
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="CanonicalBasis" Arg="U"/>
<Description>
Is the canonical basis of the quantized universal enveloping algebra <A>U</A>. 
When this  is  constructed  nothing  is  computed. By using 
<Ref Oper="PBWElements"/>, <Ref Oper="MonomialElements"/>,  
<Ref Oper="Strings"/> information about elements of
the  canonical  basis  can  be obtained. 

<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap> B:= CanonicalBasis( U );
<canonical basis of QuantumUEA( <root system of type F4>, Qpar = q ) >
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="PBWElements" Arg="B, rt"/>
<Description>
Here <A>B</A>  is  the  canonical  basis  of  a  quantized  uea,  and 
<A>rt</A> a list of non-negative  integers representing an element of the 
root lattice (e.g., if the  simple  roots  are  <M>\alpha</M>, <M>\beta</M>  
and <A>rt = [ 3, 2 ]</A>, then <A>rt</A> represents <M>3\alpha+2\beta</M>).<P/>
It  is  possible  to add the option <A>lowrank</A>, as follows 
<A>PBWElements( B, rt :lowrank  )</A>.  In  that case a somewhat different 
method will be used, that is significantly faster if the underlying root 
system has rank 2,3. It is about equally fast for ranks 4,5; and slower for 
ranks greater than 5.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap> B:= CanonicalBasis( U );;
gap> PBWElements( B, [1,2,1,0] );
[ F1*F3^(2)*F9, F1*F3*F7+(q^4)*F1*F3^(2)*F9, (q^4)*F1*F3^(2)*F9+F2*F3*F9, 
  (q^2)*F1*F3*F7+(q^6+q^2)*F1*F3^(2)*F9+(q^2)*F2*F3*F9+F2*F7, 
  (q^4)*F1*F3*F7+(q^8)*F1*F3^(2)*F9+(q^4)*F2*F3*F9+(q^2)*F2*F7+F3*F4 ]
gap> U:= QuantizedUEA( RootSystem("G",2) );;
gap> B:= CanonicalBasis( U );;
gap> PBWElements( B, [2,3] : lowrank );
[ F1^(2)*F6^(3), F1*F5*F6^(2)+(q^10+q^8)*F1^(2)*F6^(3), 
  (q^2)*F1*F5*F6^(2)+(q^12+q^6)*F1^(2)*F6^(3)+F3*F6^(2), 
  (q^8)*F1*F5*F6^(2)+(q^18)*F1^(2)*F6^(3)+(q^6)*F3*F6^(2)+F5^(2)*F6 ]
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="MonomialElements" Arg="B, rt"/>
<Description>
This does  the  same  as <Ref Oper="PBWElements"/>, except that the elements 
are written as linear combinations of monomials in the generators 
<M>F_{\alpha}</M>, where <M>\alpha</M> runs through the simple roots. <P/>
We  remark  that  this information is also computed <Q>behind the scenes</Q>
when calling  <A>PBWElements(  B,  rt  )</A>.  However, it is not computed if 
the option <A>lowrank</A> is present in the call to <A>PBWElements</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap> B:= CanonicalBasis( U );;
gap> MonomialElements( B, [1,2,1,0] );
[ F1*F3^(2)*F9, F1*F3*F9*F3+(-1)*F1*F3^(2)*F9, F3^(2)*F1*F9, F3*F1*F9*F3, 
  F3*F9*F3*F1+(-1)*F3^(2)*F1*F9 ]
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Strings" Arg="B, rt"/>
<Description>
Here <A>B</A>, <A>rt</A> are the same as in <Ref Oper="PBWElements"/>.
This returns the list of strings  corresponding  to the elements of <A>B</A> 
of weight <A>rt</A> (cf. Section <Ref Sect="sec2.6"/>).
For  example,  if on the <M>k</M>-th position of the list returned by this 
function we  have <A>[ 1, 2, 2, 3 ]</A>, then the principal monomial of the 
<M>k</M>-th element of <A>PBWElements(  B, rt )</A> is 
<M>\widetilde{F}_1^2\widetilde{F}_2^3(1)</M> (where <M>\widetilde{F}_i</M>
is the <M>i</M>-th Kashiwara operator). <P/>
We  remark  that  this information is also computed <Q>behind the scenes</Q>
when calling  <A>PBWElements(  B,  rt  )</A>.  However, it is not computed if 
the option <A>lowrank</A> is present in the call to <A>PBWElements</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap> B:= CanonicalBasis( U );;
gap> Strings( B, [1,2,1,0] );
[ [ 1, 1, 2, 2, 3, 1 ], [ 1, 1, 2, 1, 3, 1, 2, 1 ], [ 2, 2, 1, 1, 3, 1 ], 
  [ 2, 1, 1, 1, 3, 1, 2, 1 ], [ 2, 1, 3, 1, 2, 1, 1, 1 ] ]
gap> Falpha( Falpha( Falpha( Falpha( One(U), 3 ), 1 ), 2 ), 2 );
F2*F3*F9
gap> PBWElements( B, [1,2,1,0] )[3];
(q^4)*F1*F3^(2)*F9+F2*F3*F9
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="PrincipalMonomial" Arg="u"/>
<Description>
Here <A>u</A>  is  an  element of the output of <Ref Oper="PBWElements"/>. 
This function returns the unique monomial of <A>u</A> that has coefficient 1.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("G",2) );;
gap> B:= CanonicalBasis( U );;
gap> p:= PBWElements( B, [4,4] : lowrank )[4];
(q^9)*F1^(2)*F3*F6^(3)+F1^(2)*F5^(2)*F6^(2)+(q^13+q^11+q^9)*F1^(3)*F5*F6^(
3)+(q^28+q^26+2*q^24+q^22+q^20)*F1^(4)*F6^(4)
gap> PrincipalMonomial( p );
F1^(2)*F5^(2)*F6^(2)
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="StringMonomial" Arg="u"/>
<Description>
Here <A>u</A> is a monomial in the negative part of a quantized enveloping 
algebra, e.g.,  as  output by <Ref Oper="PrincipalMonomial"/>. This function
computes the corresponding <Q>string</Q> (see Section <Ref Sect="sec2.6"/>). 
The strings are output in the same way as in <Ref Sect="Strings"/>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("G",2) );;
gap> B:= CanonicalBasis( U );;
gap> p:= PBWElements( B, [1,2] : lowrank )[2];;
gap> m:=PrincipalMonomial( p );
F5*F6
gap> StringMonomial( m );
[ 2, 2, 1, 1 ]
gap> Falpha( Falpha( Falpha( One(U), 1 ), 2 ), 2 );
F5*F6
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Falpha" Label="for a module element" Arg="V, v, ind"/>
<Description>
Here  <A>V</A> is a module over a quantized enveloping algebra, <A>v</A> an 
element of it, and  <A>ind</A>  an  index  between 1 and the rank of the root 
system. The function returns  the result of applying the <A>ind</A>-th 
Kashiwara operator <M>\widetilde{F}_{<A>ind</A>}</M>
to <A>v</A>. Here the Kashiwara operators are different from the ones 
described in Section <Ref Sect="sec2.6"/>. We refer to <Cite Key="J96"/>, 9.2 
for the definition of the operators used here.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("B",2) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> Falpha( V, Basis(V)[1], 1 );
F1*v0
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Ealpha" Label="for a module element" Arg="V, v, ind"/>
<Description>
Here  <A>V</A> is a module over a quantized enveloping algebra, <A>v</A> an 
element of it, and  <A>ind</A>  an  index  between 1 and the rank of the root 
system. The function returns  the result of applying the <A>ind</A>-th 
Kashiwara operator <M>\widetilde{E}_{<A>ind</A>}</M>
to <A>v</A>. Here the Kashiwara operators are different from the ones 
described in Section <Ref Sect="sec2.6"/>. We refer to <Cite Key="J96"/>, 9.2 
for the definition of the operators used here.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("B",2) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> v:= Falpha( V, Basis(V)[2], 2 );
(q^2)*F1*F4*v0+F2*v0
gap> Ealpha( V, v, 2 );
F1*v0
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="CrystalBasis" Arg="V"/>
<Description>
Here  <A>V</A>  is  a  finite-dimensional  left  module over a quantized 
enveloping algebra.  This  function  returns  the canonical, or crystal basis 
of V (see Section <Ref Sect="sec2.6"/>).<P/>
This  function  only  works for modules for which 
<Ref Oper="WeightsAndVectors"/> works.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap> V:= HighestWeightModule( U, [1,1] );
<16-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>
gap>  CrystalBasis( V );
Basis( <16-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>, [ 1*v0, F1*v0, F4*v0, F1*F4*v0, (q^2)*F1*F4*v0+F2*v0, 
  F2*F4*v0, (q)*F2*F4*v0+F3*v0, (-q^-4)*F1*F2*v0, 
  (-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0, (-q^-2)*F2^(2)*v0, F3*F4*v0, 
  (-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F4*v0, (-q^-2)*F2*F3*v0, (q^-4)*F2^(3)*v0, 
  (-q^-1)*F3^(2)*v0, (q^-5)*F2^(2)*F3*v0 ] )
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="CrystalVectors" Arg="V"/>
<Description>
Here  <A>V</A>  is  a  finite-dimensional  left  module over a quantized 
enveloping algebra. Let <A>C</A> be the crystal  basis of <A>V</A> (i.e., 
output by <Ref Attr="CrystalBasis"/>). This function returns a list of cosets 
of the basis elements of <A>C</A> modulo <M>qL</M>, where <M>L</M> is the 
<M>\mathbb{Z}[q]</M>-lattice spanned by <A>C</A>. <P/>
The coset of a vector <A>v</A> is printed as <A>&lt;v></A>. <P/>
The crystal vectors are used to construct the point set of the crystal graph
of <A>V</A> (<Ref Func="CrystalGraph" Label="for a module"/>). <P/>
This  function  only  works for modules for which 
<Ref Oper="WeightsAndVectors"/> works.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap> V:= HighestWeightModule( U, [1,1] );
<16-dimensional left-module over QuantumUEA( <root system of type B
2>, Qpar = q )>
gap> CrystalVectors( V );
[ <1*v0>, <F1*v0>, <F4*v0>, <F2*v0>, <F1*F4*v0>, <F3*v0>, <(-q^-4)*F1*F2*v0>, 
  <F2*F4*v0>, <F1*F3*v0>, <F3*F4*v0>, <(-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0>, 
  <(-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F4*v0>, <F2^(2)*F4*v0>, <(q^-4)*F2^(3)*v0>,
  <(-q^-1)*F3^(2)*v0>, <(q^-5)*F2^(2)*F3*v0> ]
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="Falpha" Label="for a crystal vector" Arg="v, ind"/>
<Description>
Here <A>v</A> is a crystal vector, i.e., an element of 
<A>CrystalVectors( V )</A>, where <A>V</A> is a left module over a
quantized enveloping algebra. This function  returns  the  result  of  
applying  the  <A>ind</A>-th Kashiwara operator
<M>\widetilde{F}_{\alpha_{<A>ind</A>}}</M> to v. The result is <A>fail</A>    
if <M>\widetilde{F}_{\alpha_{<A>ind</A>}}</M><A>(v)=0</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> c:=CrystalVectors( V );;
gap> Falpha( c[2], 2 );
<F2*v0>
gap> Falpha( c[3], 2 );
fail
gap> Falpha( Falpha( Falpha( c[1], 1 ), 2 ), 1 );
fail
gap> p:= DominantLSPath( RootSystem( "B", 2 ), [1,1] );
<LS path of shape [ 1, 1 ] ending in [ 1, 1 ] >
gap> Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );
fail
]]></Example>
The  last  part  of  this  example  is  an illustration of the fact that the
crystal  graph of a highest-weight module can be obtained by the path method
(see Section <Ref Sect="sec2.7"/>).
</Description>
</ManSection>

<ManSection> 
<Oper Name="Ealpha" Label="for a crystal vector" Arg="v, ind"/>
<Description>
Here <A>v</A> is a crystal vector, i.e., an element of 
<A>CrystalVectors( V )</A>, where <A>V</A> is a left module over a
quantized enveloping algebra. This function  returns  the  result  of  
applying  the  <A>ind</A>-th Kashiwara operator
<M>\widetilde{E}_{\alpha_{<A>ind</A>}}</M> to v. The result is <A>fail</A>    
if <M>\widetilde{E}_{\alpha_{<A>ind</A>}}</M><A>(v)=0</A>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap> V:= HighestWeightModule( U, [1,1] );;
gap> c:=CrystalVectors( V );;
gap> Ealpha( c[3], 1 );
fail
gap> Ealpha( c[3], 2 );
<1*v0>
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Func Name="CrystalGraph" Label="for a module" Arg="V"/>
<Description>
Returns  the crystal graph of the module <A>V</A>. The points of this graph 
are the cosets output by <Ref Attr="CrystalVectors"/>. The edges work in the 
same way as in  <Ref Func="CrystalGraph" Label="for root system and weight"/>.
<Example><![CDATA[
gap> U:= QuantizedUEA( RootSystem("A",2) );;
gap> V1:= HighestWeightModule( U, [1,0] );;
gap> V2:= HighestWeightModule( U, [0,1] );;
gap> W:= TensorProductOfAlgebraModules( V1, V2 );;
gap> CrystalGraph( W );
rec( 
  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ], 
      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ], 
      [ [ 7, 8 ], 2 ] ], 
  points := [ <1*(1*v0<x>1*v0)>, <1*(F1*v0<x>1*v0)>, <1*(1*v0<x>F3*v0)>, 
      <1*(1*v0<x>F2*v0)+q^-1*(F2*v0<x>1*v0)>, 
      <-q^-1*(1*v0<x>F2*v0)+q^-1*(F1*v0<x>F3*v0)>, <1*(F2*v0<x>F3*v0)>, 
      <-q^-1*(F1*v0<x>F2*v0)>, <-q^-1*(F2*v0<x>F2*v0)>, 
      <-q^-3*(1*v0<x>F2*v0)+-q^-1*(F1*v0<x>F3*v0)+1*(F2*v0<x>1*v0)> ] )
]]></Example>
</Description>
</ManSection>

</Section>

<Section> <Heading> Universal enveloping algebras </Heading>
Here  we describe functions for connecting a quantized enveloping algebra to
the corresponding universal enveloping algebra.

<ManSection> 
<Attr Name="UEA" Arg="L"/>
<Description>
This  function  returns the universal enveloping algebra <A>u</A> of the 
semisimple Lie  algebra <A>L</A>. The generators of <A>u</A> are the 
generators of a Kostant lattice in the universal enveloping algebra (these 
generators are obtained from <A>L</A> by
<A>LatticeGeneratorsInUEA( L )</A>, see the &GAP; reference manual).
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "B", 2, Rationals );
<Lie algebra of dimension 10 over Rationals>
gap> u:= UEA( L );
<algebra over Rationals, with 10 generators>
gap> g:= GeneratorsOfAlgebra( u );
[ y1, y2, y3, y4, x1, x2, x3, x4, ( h9/1 ), ( h10/1 ) ]
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="UnderlyingLieAlgebra" Arg="u"/>
<Description>
For  a  universal  enveloping  algebra  <A>u</A>  constructed by 
<Ref Attr="UEA"/>, this returns the corresponding semisimple Lie algebra
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "B", 2, Rationals );;
gap> u:= UEA( L );;
gap> UnderlyingLieAlgebra( u );
<Lie algebra of dimension 10 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Oper Name="HighestWeightModule" Label="for a universal env. alg" Arg="u, hw"/>
<Description>
For a universal enveloping algebra <A>u</A> constructed by <Ref Attr="UEA"/>, 
this returns the irreducible highest weight module over <A>u</A> with highest 
weight <A>hw</A>, which must be dominant. This module
is the same as the corresponding highest weight module over the semisimple
Lie algebra, but in this case the enveloping algebra <A>u</A> acts.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "B", 2, Rationals );;
gap> u:= UEA( L );;
gap> HighestWeightModule( u, [2,3] );
<140-dimensional left-module over <algebra over Rationals, with 
10 generators>>
]]></Example>
</Description>
</ManSection>

<ManSection> 
<Attr Name="QUEAToUEAMap" Arg="L"/>
<Description>
Here <A>L</A> is a semisimple Lie algebra. Set <A>u := UEA( L )</A>, and 
<A>U := QuantizedUEA( L )</A> (so <A>u, U</A> are the universal enveloping 
algebra, and <Q>generic</Q>  quantized  enveloping  algebra  of  <A>L</A>  
respectively). Then <A>QUEAToUEAMap( L )</A> returns the algebra homomorphism 
from <A>U</A> to <A>u</A> obtained by mapping <A>q</A> to <A>1</A>, a 
generator <A>Fi</A>, corresponding to a simple root to the generator 
<A>yi</A> (corresponding to the same simple root), and likewise for <A>Ei</A>
and <A>xi</A>. This means that <A>Ki</A> is mapped to one, and 
<A>[ Ki : s ]</A> to <A>hi</A> choose <A>s</A>. <P/>
The canonical basis of <A>U</A> is mapped to the canonical basis of <A>u</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "B", 2, Rationals );;
gap> f:= QUEAToUEAMap( L );
<mapping: QuantumUEA( <root system of rank 
2>, Qpar = q ) -> Algebra( Rationals, [ y1, y2, y3, y4, x1, x2, x3, x4, 
  ( h9/1 ), ( h10/1 ) ] ) >
gap> U:= Source( f );
QuantumUEA( <root system of rank 2>, Qpar = q )
gap> u:= Range( f );
<algebra over Rationals, with 10 generators>
gap> B:= CanonicalBasis( U );;
gap> p:= PBWElements( B, [1,2] );
[ F1*F4^(2), (q^3+q)*F1*F4^(2)+F2*F4, (q^4)*F1*F4^(2)+(q)*F2*F4+F3 ]
gap> pu:= List( p, x -> Image( f, x ) );
[ y1*y2^(2), 2*y1*y2^(2)+y2*y3-2*y4, y1*y2^(2)+y2*y3-1*y4 ]
gap> V:= HighestWeightModule( u, [2,1] );
<40-dimensional left-module over <algebra over Rationals, with 10 generators>>
gap> List( pu, x -> x^Basis(V)[1] );
[ 0*v0, y2*y3*v0-2*y4*v0, y2*y3*v0-1*y4*v0 ]
gap> # Which gives us a piece of the canonical basis of V.
]]></Example>
</Description>
</ManSection>


</Section>

</Chapter>


</Body>

<Bibliography Databases="quagroup" />

<TheIndex/>

</Book>

